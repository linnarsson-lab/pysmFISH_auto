from typing import *
import os
import yaml
from pathlib import Path
from collections import OrderedDict

from prefect import task
from prefect.engine import signals

from pysmFISH.logger_utils import prefect_logging_setup


# to avoid reference for nested structures
# https://stackoverflow.com/questions/13518819/avoid-references-in-pyyaml (comment)
yaml.SafeDumper.ignore_aliases = lambda *args : True



@task(name='check_completed_transfer_to_monod')
def check_completed_transfer_to_monod(path_tmp_storage_server:str, flag_file_key:str):
    """
    Function to scan the folder where the data are transferred from the machines.
    It looks for files that are generated upon transfer completion (flag_file).
    To keep thing simple and not overload the system only one of the flag_files
    identified in the scanning of the folder will be processed.
    
    NB: In order to process only the experiments designed for the pipeline 
    the folder name finish with auto ExpName_auto

    Args: 
    path_tmp_storage_server: str
        path where the data are transferred from the microscopes
    flag_file_key: str
        string that define the flag_files. The flag key should not have _auto_
        in the name.


    Returns:
        experiment_path: Posix
            experiment path in the tmp folder
    """

    logger = prefect_logging_setup('check_completed_transfer_to_monod')
    path_tmp_storage_server = Path(path_tmp_storage_server)
    flag_file_key_general = '*_auto_' + flag_file_key
    flag_file_key = '_' + flag_file_key
    flagged_files_list = list(path_tmp_storage_server.glob(flag_file_key_general))
    

    if flagged_files_list:
        flagged_file_path = flagged_files_list[0]
        experiment_name = (flagged_file_path.name).split(flag_file_key)[0]
        logger.info(f'{experiment_name} ready to be processed')
        os.remove(flagged_file_path)
        return flagged_file_path.parent / experiment_name
    else:
        logger.info(f'No new experiments to be processed')
        skip_signal = signals.SKIP("No new experiments to be processed")
        skip_signal.flag = True
        skip_signal.value = None
        raise skip_signal


@task(name='load_experiments_info_file')
def load_experiment_config_file(experiment_fpath:str):
    """
    Function that load the experiment general information generated by the
    machines.

    Args:
        experiment_fpath: str
            location of the folder to be processed
    Return:
        experiment_info: ordered dict
            ordered dict with the parsed info generated by the instrument

    """
    
    logger = prefect_logging_setup('load_experiments_info_file')

    experiment_fpath = Path(experiment_fpath)
    experiment_name = experiment_fpath.stem
    search_key = experiment_name + '_config.yaml'
    
    try:
        experiment_info_fpath = list(experiment_fpath.glob(search_key))[0]
    except:
        logger.error(f'No experiment info file in {experiment_fpath}')
        fail_signal = signals.FAIL("No experiment info file in the folder")
        fail_signal.flag = True
        fail_signal.value = None
        raise fail_signal
    
    try:
        experiment_info = OrderedDict(yaml.safe_load(open(experiment_info_fpath, 'rb')))
        return experiment_info
    except:
        logger.error(f'Experiment info file has the wrong name in {experiment_fpath}')
        fail_signal = signals.FAIL("Experiment info file has the wrong name in the folder")
        fail_signal.flag = True
        fail_signal.value = None
        raise fail_signal





@task(name='create_raw_and_tmp_folders')
def create_raw_tmp_folders(experiment_fpath:str):
    """
    Function used to create the folders where to 
    store the renamed raw data and the parsed files

    Args:
        experiment_fpath: str
            folder path of the experiment
    """
    logger = prefect_logging_setup('created_raw_tmp_dir')
    experiment_fpath = Path(experiment_fpath)
    folders_list = ['raw_data','parsed_tmp']
    for folder_name in folders_list:
        try:
            os.stat(experiment_fpath / folder_name )
            logger.info(f'{folder_name} already exist')
        except:
            os.mkdir(experiment_fpath / folder_name)
            os.chmod(experiment_fpath / folder_name,0o777)


