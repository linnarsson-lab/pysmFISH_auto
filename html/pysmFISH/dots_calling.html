<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>pysmFISH.dots_calling API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pysmFISH.dots_calling</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from typing import *
import numpy as np
import argparse
import zarr
import re
import sys
import logging
import pickle
import pandas as pd
from sympy import Point, Line
from skimage import feature, measure, img_as_float
from scipy import ndimage as nd
from pathlib import Path

from pysmFISH.utils import load_pipeline_config_file, convert_from_uint16_to_float64


from prefect import task
from prefect.engine import signals

from pysmFISH.logger_utils import prefect_logging_setup



class osmFISH_dots_thr_selection():

    &#39;&#39;&#39;
    Class used to calculate and optimise the thr for the identification of the dots.
    

    Attributes:
    -----------
    img

    Returns:
    ---------
    &#39;&#39;&#39;
    
    def __init__(self, img:np.ndarray, parameters_dict:Dict, min_int:float=False, max_int:float=False,min_peaks:int=False):
        self.img = img
        self.parameters_dict = parameters_dict
        self.min_int = min_int
        self.max_int = max_int
        self.min_peaks = min_peaks

        if self.min_peaks == False:
            self.min_peaks = 3
        
        self.min_distance = self.parameters_dict[&#39;min_distance&#39;]
        
        self.fill_value = np.nan

        # List with the total peaks calculated for each threshold
        self.total_peaks = []
        self.thr_used = []

    def counting_graph(self):

        # Define the range of thr to be tested
        if self.min_int and self.max_int:
            self.thr_array = np.linspace(self.min_int,self.max_int,num=100)
        elif self.min_int:
            self.thr_array = np.linspace(self.min_int,self.img.max(),num=100)
        elif self.max_int:
            self.thr_array = np.linspace(self.img.min(),self.max_int,num=100)
        else:
            self.thr_array = np.linspace(self.img.min(),self.img.max(),num=100)
    
        # Calculate the number of peaks for each threshold. In this calculation
        # the size of the objects is not considered
        self.peak_counter_min = 0
        self.peak_counter_max = 0
        for vl, thr in enumerate(self.thr_array):
            # The border is excluded from the counting
            self.peaks = feature.peak_local_max(self.img,min_distance=self.min_distance,\
                threshold_abs=thr,exclude_border=False, indices=True,\
                num_peaks=np.inf, footprint=None,labels=None)
            
            self.number_peaks = len(self.peaks)

            # Stop the counting when the number of peaks detected falls below 3
            if self.number_peaks&lt;=self.min_peaks:
                self.stop_thr = thr # Move in the upper loop so you will stop at the previous thr
                break
            else:
                self.total_peaks.append(len(self.peaks))
                self.thr_used.append(thr)

    def thr_identification(self):  
        # Consider the case of no detectected peaks or if there is only one Thr
        # that create peaks (list total_peaks have only one element and )
        # if np.array(total_peaks).sum()&gt;0 or len(total_peaks)&gt;1:
        if len(self.total_peaks)&gt;1:

            # Trim the threshold array in order to match the stopping point
            # used the [0][0] to get the first number and then take it out from list
            # thr_array = thr_array[:np.where(thr_array==stop_thr)[0][0]]
            self.thr_array = np.array(self.thr_used)

            # Calculate the gradient of the number of peaks distribution
            grad = np.gradient(self.total_peaks)
            
            # Restructure the data in order to avoid to consider the min_peak in the
            # calculations

            # Coord of the gradient min_peak
            grad_min_peak_coord = np.argmin(grad)
            
            # Trim the data to remove the peak.
            self.trimmed_thr_array = self.thr_array[grad_min_peak_coord:]
            self.trimmed_grad = grad[grad_min_peak_coord:]

            if self.trimmed_thr_array.shape&gt;(1,):

                # Trim the coords array in order to maintain the same length of the 
                # tr and pk
                self.trimmed_total_peaks = self.total_peaks[grad_min_peak_coord:]

                # To determine the threshold we will determine the Thr with the biggest
                # distance to the segment that join the end points of the calculated
                # gradient

                # Distances list
                distances = []

                # Calculate the coords of the end points of the gradient
                p1 = Point(self.trimmed_thr_array[0],self.trimmed_grad[0])
                p2 = Point(self.trimmed_thr_array[-1],self.trimmed_grad[-1])
                
                # Create a line that join the points
                s = Line(p1,p2)
                allpoints = np.arange(0,len(self.trimmed_thr_array))
                
                # Calculate the distance between all points and the line
                for p in allpoints:
                    dst = s.distance(Point(self.trimmed_thr_array[p],self.trimmed_grad[p]))
                    distances.append(dst.evalf())

                # Remove the end points from the lists
                self.trimmed_thr_array = self.trimmed_thr_array[1:-1]
                self.trimmed_grad = self.trimmed_grad[1:-1]
                self.trimmed_total_peaks = self.trimmed_total_peaks[1:-1]
                self.trimmed_distances = distances[1:-1]
            
                # Determine the coords of the selected Thr
                # Converted trimmed_distances to array because it crashed
                # on Sanger.
                if self.trimmed_distances: # Most efficient way will be to consider the length of Thr list
                    thr_idx = np.argmax(np.array(self.trimmed_distances))
                    self.selected_thr = self.trimmed_thr_array[thr_idx]
                    # The selected threshold usually causes oversampling of the number of dots
                    # I added a stringency parameter (int n) to use to select the Thr+n 
                    # for the counting. It selects a stringency only if the trimmed_thr_array
                    # is long enough. Also consider the case in which the stringency in negative
                else:
                    self.selected_thr = self.fill_value
                    self.trimmed_thr_array = self.fill_value
            else:
                self.selected_thr = self.fill_value
                self.trimmed_thr_array = self.fill_value
        else:
            self.selected_thr = self.fill_value
            self.trimmed_thr_array = self.fill_value


class osmFISH_dots_mapping():

    def __init__(self,img,thr,parameters_dict):
       # Calculate the selected peaks after removal of the big and small objects
        
        self.img = img
        self.thr = thr
        # make an error if selected Thr &lt;0
        self.parameters_dict = parameters_dict
        
        self.min_distance = self.parameters_dict[&#39;min_distance&#39;]
        self.min_obj_size = self.parameters_dict[&#39;min_obj_size&#39;]
        self.max_obj_size = self.parameters_dict[&#39;max_obj_size&#39;]
        self.num_peaks_per_label = self.parameters_dict[&#39;num_peaks_per_label&#39;]

        self.fill_value = np.nan

        # Threshold the image using the selected threshold
        img_mask = self.img&gt;self.thr
    
        labels = nd.label(img_mask)[0]
        
        properties = measure.regionprops(labels)
            
        for ob in properties:
            if ob.area&lt;self.min_obj_size or ob.area&gt;self.max_obj_size:
                img_mask[ob.coords[:,0],ob.coords[:,1]]=0
        
        labels = nd.label(img_mask)[0]

        # Collect the properties of the labels after size selection
        properties = measure.regionprops(labels,intensity_image=self.img)

        self.selected_peaks = feature.peak_local_max(self.img, min_distance=self.min_distance, 
                                threshold_abs=self.thr, exclude_border=False, indices=True, num_peaks=np.inf, 
                                footprint=None, labels=labels,num_peaks_per_label=self.num_peaks_per_label)                            
        
        if self.selected_peaks.size:
            self.intensity_array = self.img[self.selected_peaks[:,0],self.selected_peaks[:,1]]
        else:
            self.intensity_array = np.nan


@task(name=&#39;peak-based-detection&#39;)
def osmFISH_peak_based_detection(img_meta:tuple,
                                        min_distance: np.float64,
                                        min_obj_size: np.uint16,
                                        max_obj_size: np.uint16,
                                        num_peaks_per_label: np.uint16):
    
    &#34;&#34;&#34;
    This funtion apply the same peak based detection strategy used for 
    dots calling in the osmFISH paper
    
    Args:
    -----------
    img_meta: tuple
        tuple containing (image np.ndarray and metadata dict)
    min_distance: np.float64
        minimum distance between two peaks
    min_obj_size: np.uint16
        minimum object size of the objects that will be processed for peak detection
        objects below this value are discharged
    max_obj_size: np.uint16
        maximum object size of the objects that will be processed for peak detection
        objects above this value are discharged
    num_peaks_per_label: np.uint16
        Max number of peaks detected in each segmented object. Use None for max detection

    &#34;&#34;&#34;

    logger = prefect_logging_setup(f&#39;osmFISH_barcoded_peak_based_detection&#39;)

    img = img_meta[0]
    img_metadata = img_meta[1]
    fov = img_metadata[&#39;fov_num&#39;]
    hybridization_num = img_metadata[&#39;hybridization_num&#39;]

    counting_parameters_dict = {
                            &#39;min_distance&#39;: min_distance,
                            &#39;min_obj_size&#39;: min_obj_size,
                            &#39;max_obj_size&#39;: max_obj_size,
                            &#39;num_peaks_per_label&#39;: num_peaks_per_label,
                                }
    fill_value = np.nan
    counts = osmFISH_dots_thr_selection(img,counting_parameters_dict)
    counts.counting_graph()
    counts.thr_identification()

    if not np.isnan(counts.selected_thr):
            dots = osmFISH_dots_mapping(img,counts.selected_thr,counting_parameters_dict)
            if isinstance(dots.selected_peaks,np.ndarray):
                total_dots = dots.selected_peaks.shape[0]
                dot_id_array = np.array([str(fov)+&#39;_&#39;+str(hybridization_num)+&#39;_&#39;+ img_metadata[&#39;channel&#39;] +&#39;_&#39;+str(nid) for nid in range(total_dots)])
                fov_array = np.repeat(fov,total_dots)
                thr_array = np.repeat(counts.selected_thr,total_dots)
                channel_array = np.repeat(img_metadata[&#39;channel&#39;],total_dots)
                counts_dict = {
                    &#39;DotsCoordsFOV&#39;: dots.selected_peaks,
                    &#39;DotID&#39;: dot_id_array,
                    &#39;FovNumber&#39;: fov_array,
                    &#39;DotIntensity&#39;: dots.intensity_array,
                    &#39;SelectedThreshold&#39;:thr_array,
                    &#39;DotChannel&#39;:channel_array}
            else:
                logger.info(&#39;f fov {fov} does not have counts (mapping)&#39;)
                counts_dict = {
                    &#39;DotsCoordsFOV&#39;: np.array([fill_value, fill_value]),
                    &#39;DotID&#39;: np.array([fill_value]),
                    &#39;FovNumber&#39;: np.array(fov),
                    &#39;DotIntensity&#39;: np.array([fill_value]),
                    &#39;SelectedThreshold&#39;:np.array([fill_value]),
                    &#39;DotChannel&#39;:np.array([fill_value])}
    else:
        logger.info(&#39;f fov {fov} does not have counts (thr)&#39;)
        counts_dict = {
                    &#39;DotsCoordsFOV&#39;: np.array([fill_value, fill_value]),
                    &#39;DotID&#39;: np.array([fill_value]),
                    &#39;FovNumber&#39;: np.array(fov),
                    &#39;DotIntensity&#39;: np.array([fill_value]),
                    &#39;SelectedThreshold&#39;:np.array([fill_value]),
                    &#39;DotChannel&#39;:np.array([fill_value])}
    
    return (counts_dict, img_metadata)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pysmFISH.dots_calling.osmFISH_peak_based_detection"><code class="name flex">
<span>def <span class="ident">osmFISH_peak_based_detection</span></span>(<span>img_meta: tuple, min_distance: numpy.float64, min_obj_size: numpy.uint16, max_obj_size: numpy.uint16, num_peaks_per_label: numpy.uint16)</span>
</code></dt>
<dd>
<div class="desc"><p>This funtion apply the same peak based detection strategy used for
dots calling in the osmFISH paper</p>
<h2 id="args">Args:</h2>
<p>img_meta: tuple
tuple containing (image np.ndarray and metadata dict)
min_distance: np.float64
minimum distance between two peaks
min_obj_size: np.uint16
minimum object size of the objects that will be processed for peak detection
objects below this value are discharged
max_obj_size: np.uint16
maximum object size of the objects that will be processed for peak detection
objects above this value are discharged
num_peaks_per_label: np.uint16
Max number of peaks detected in each segmented object. Use None for max detection</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@task(name=&#39;peak-based-detection&#39;)
def osmFISH_peak_based_detection(img_meta:tuple,
                                        min_distance: np.float64,
                                        min_obj_size: np.uint16,
                                        max_obj_size: np.uint16,
                                        num_peaks_per_label: np.uint16):
    
    &#34;&#34;&#34;
    This funtion apply the same peak based detection strategy used for 
    dots calling in the osmFISH paper
    
    Args:
    -----------
    img_meta: tuple
        tuple containing (image np.ndarray and metadata dict)
    min_distance: np.float64
        minimum distance between two peaks
    min_obj_size: np.uint16
        minimum object size of the objects that will be processed for peak detection
        objects below this value are discharged
    max_obj_size: np.uint16
        maximum object size of the objects that will be processed for peak detection
        objects above this value are discharged
    num_peaks_per_label: np.uint16
        Max number of peaks detected in each segmented object. Use None for max detection

    &#34;&#34;&#34;

    logger = prefect_logging_setup(f&#39;osmFISH_barcoded_peak_based_detection&#39;)

    img = img_meta[0]
    img_metadata = img_meta[1]
    fov = img_metadata[&#39;fov_num&#39;]
    hybridization_num = img_metadata[&#39;hybridization_num&#39;]

    counting_parameters_dict = {
                            &#39;min_distance&#39;: min_distance,
                            &#39;min_obj_size&#39;: min_obj_size,
                            &#39;max_obj_size&#39;: max_obj_size,
                            &#39;num_peaks_per_label&#39;: num_peaks_per_label,
                                }
    fill_value = np.nan
    counts = osmFISH_dots_thr_selection(img,counting_parameters_dict)
    counts.counting_graph()
    counts.thr_identification()

    if not np.isnan(counts.selected_thr):
            dots = osmFISH_dots_mapping(img,counts.selected_thr,counting_parameters_dict)
            if isinstance(dots.selected_peaks,np.ndarray):
                total_dots = dots.selected_peaks.shape[0]
                dot_id_array = np.array([str(fov)+&#39;_&#39;+str(hybridization_num)+&#39;_&#39;+ img_metadata[&#39;channel&#39;] +&#39;_&#39;+str(nid) for nid in range(total_dots)])
                fov_array = np.repeat(fov,total_dots)
                thr_array = np.repeat(counts.selected_thr,total_dots)
                channel_array = np.repeat(img_metadata[&#39;channel&#39;],total_dots)
                counts_dict = {
                    &#39;DotsCoordsFOV&#39;: dots.selected_peaks,
                    &#39;DotID&#39;: dot_id_array,
                    &#39;FovNumber&#39;: fov_array,
                    &#39;DotIntensity&#39;: dots.intensity_array,
                    &#39;SelectedThreshold&#39;:thr_array,
                    &#39;DotChannel&#39;:channel_array}
            else:
                logger.info(&#39;f fov {fov} does not have counts (mapping)&#39;)
                counts_dict = {
                    &#39;DotsCoordsFOV&#39;: np.array([fill_value, fill_value]),
                    &#39;DotID&#39;: np.array([fill_value]),
                    &#39;FovNumber&#39;: np.array(fov),
                    &#39;DotIntensity&#39;: np.array([fill_value]),
                    &#39;SelectedThreshold&#39;:np.array([fill_value]),
                    &#39;DotChannel&#39;:np.array([fill_value])}
    else:
        logger.info(&#39;f fov {fov} does not have counts (thr)&#39;)
        counts_dict = {
                    &#39;DotsCoordsFOV&#39;: np.array([fill_value, fill_value]),
                    &#39;DotID&#39;: np.array([fill_value]),
                    &#39;FovNumber&#39;: np.array(fov),
                    &#39;DotIntensity&#39;: np.array([fill_value]),
                    &#39;SelectedThreshold&#39;:np.array([fill_value]),
                    &#39;DotChannel&#39;:np.array([fill_value])}
    
    return (counts_dict, img_metadata)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pysmFISH.dots_calling.osmFISH_dots_mapping"><code class="flex name class">
<span>class <span class="ident">osmFISH_dots_mapping</span></span>
<span>(</span><span>img, thr, parameters_dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class osmFISH_dots_mapping():

    def __init__(self,img,thr,parameters_dict):
       # Calculate the selected peaks after removal of the big and small objects
        
        self.img = img
        self.thr = thr
        # make an error if selected Thr &lt;0
        self.parameters_dict = parameters_dict
        
        self.min_distance = self.parameters_dict[&#39;min_distance&#39;]
        self.min_obj_size = self.parameters_dict[&#39;min_obj_size&#39;]
        self.max_obj_size = self.parameters_dict[&#39;max_obj_size&#39;]
        self.num_peaks_per_label = self.parameters_dict[&#39;num_peaks_per_label&#39;]

        self.fill_value = np.nan

        # Threshold the image using the selected threshold
        img_mask = self.img&gt;self.thr
    
        labels = nd.label(img_mask)[0]
        
        properties = measure.regionprops(labels)
            
        for ob in properties:
            if ob.area&lt;self.min_obj_size or ob.area&gt;self.max_obj_size:
                img_mask[ob.coords[:,0],ob.coords[:,1]]=0
        
        labels = nd.label(img_mask)[0]

        # Collect the properties of the labels after size selection
        properties = measure.regionprops(labels,intensity_image=self.img)

        self.selected_peaks = feature.peak_local_max(self.img, min_distance=self.min_distance, 
                                threshold_abs=self.thr, exclude_border=False, indices=True, num_peaks=np.inf, 
                                footprint=None, labels=labels,num_peaks_per_label=self.num_peaks_per_label)                            
        
        if self.selected_peaks.size:
            self.intensity_array = self.img[self.selected_peaks[:,0],self.selected_peaks[:,1]]
        else:
            self.intensity_array = np.nan</code></pre>
</details>
</dd>
<dt id="pysmFISH.dots_calling.osmFISH_dots_thr_selection"><code class="flex name class">
<span>class <span class="ident">osmFISH_dots_thr_selection</span></span>
<span>(</span><span>img: numpy.ndarray, parameters_dict: Dict, min_int: float = False, max_int: float = False, min_peaks: int = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Class used to calculate and optimise the thr for the identification of the dots.</p>
<h2 id="attributes">Attributes:</h2>
<p>img</p>
<h2 id="returns">Returns:</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class osmFISH_dots_thr_selection():

    &#39;&#39;&#39;
    Class used to calculate and optimise the thr for the identification of the dots.
    

    Attributes:
    -----------
    img

    Returns:
    ---------
    &#39;&#39;&#39;
    
    def __init__(self, img:np.ndarray, parameters_dict:Dict, min_int:float=False, max_int:float=False,min_peaks:int=False):
        self.img = img
        self.parameters_dict = parameters_dict
        self.min_int = min_int
        self.max_int = max_int
        self.min_peaks = min_peaks

        if self.min_peaks == False:
            self.min_peaks = 3
        
        self.min_distance = self.parameters_dict[&#39;min_distance&#39;]
        
        self.fill_value = np.nan

        # List with the total peaks calculated for each threshold
        self.total_peaks = []
        self.thr_used = []

    def counting_graph(self):

        # Define the range of thr to be tested
        if self.min_int and self.max_int:
            self.thr_array = np.linspace(self.min_int,self.max_int,num=100)
        elif self.min_int:
            self.thr_array = np.linspace(self.min_int,self.img.max(),num=100)
        elif self.max_int:
            self.thr_array = np.linspace(self.img.min(),self.max_int,num=100)
        else:
            self.thr_array = np.linspace(self.img.min(),self.img.max(),num=100)
    
        # Calculate the number of peaks for each threshold. In this calculation
        # the size of the objects is not considered
        self.peak_counter_min = 0
        self.peak_counter_max = 0
        for vl, thr in enumerate(self.thr_array):
            # The border is excluded from the counting
            self.peaks = feature.peak_local_max(self.img,min_distance=self.min_distance,\
                threshold_abs=thr,exclude_border=False, indices=True,\
                num_peaks=np.inf, footprint=None,labels=None)
            
            self.number_peaks = len(self.peaks)

            # Stop the counting when the number of peaks detected falls below 3
            if self.number_peaks&lt;=self.min_peaks:
                self.stop_thr = thr # Move in the upper loop so you will stop at the previous thr
                break
            else:
                self.total_peaks.append(len(self.peaks))
                self.thr_used.append(thr)

    def thr_identification(self):  
        # Consider the case of no detectected peaks or if there is only one Thr
        # that create peaks (list total_peaks have only one element and )
        # if np.array(total_peaks).sum()&gt;0 or len(total_peaks)&gt;1:
        if len(self.total_peaks)&gt;1:

            # Trim the threshold array in order to match the stopping point
            # used the [0][0] to get the first number and then take it out from list
            # thr_array = thr_array[:np.where(thr_array==stop_thr)[0][0]]
            self.thr_array = np.array(self.thr_used)

            # Calculate the gradient of the number of peaks distribution
            grad = np.gradient(self.total_peaks)
            
            # Restructure the data in order to avoid to consider the min_peak in the
            # calculations

            # Coord of the gradient min_peak
            grad_min_peak_coord = np.argmin(grad)
            
            # Trim the data to remove the peak.
            self.trimmed_thr_array = self.thr_array[grad_min_peak_coord:]
            self.trimmed_grad = grad[grad_min_peak_coord:]

            if self.trimmed_thr_array.shape&gt;(1,):

                # Trim the coords array in order to maintain the same length of the 
                # tr and pk
                self.trimmed_total_peaks = self.total_peaks[grad_min_peak_coord:]

                # To determine the threshold we will determine the Thr with the biggest
                # distance to the segment that join the end points of the calculated
                # gradient

                # Distances list
                distances = []

                # Calculate the coords of the end points of the gradient
                p1 = Point(self.trimmed_thr_array[0],self.trimmed_grad[0])
                p2 = Point(self.trimmed_thr_array[-1],self.trimmed_grad[-1])
                
                # Create a line that join the points
                s = Line(p1,p2)
                allpoints = np.arange(0,len(self.trimmed_thr_array))
                
                # Calculate the distance between all points and the line
                for p in allpoints:
                    dst = s.distance(Point(self.trimmed_thr_array[p],self.trimmed_grad[p]))
                    distances.append(dst.evalf())

                # Remove the end points from the lists
                self.trimmed_thr_array = self.trimmed_thr_array[1:-1]
                self.trimmed_grad = self.trimmed_grad[1:-1]
                self.trimmed_total_peaks = self.trimmed_total_peaks[1:-1]
                self.trimmed_distances = distances[1:-1]
            
                # Determine the coords of the selected Thr
                # Converted trimmed_distances to array because it crashed
                # on Sanger.
                if self.trimmed_distances: # Most efficient way will be to consider the length of Thr list
                    thr_idx = np.argmax(np.array(self.trimmed_distances))
                    self.selected_thr = self.trimmed_thr_array[thr_idx]
                    # The selected threshold usually causes oversampling of the number of dots
                    # I added a stringency parameter (int n) to use to select the Thr+n 
                    # for the counting. It selects a stringency only if the trimmed_thr_array
                    # is long enough. Also consider the case in which the stringency in negative
                else:
                    self.selected_thr = self.fill_value
                    self.trimmed_thr_array = self.fill_value
            else:
                self.selected_thr = self.fill_value
                self.trimmed_thr_array = self.fill_value
        else:
            self.selected_thr = self.fill_value
            self.trimmed_thr_array = self.fill_value</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pysmFISH.dots_calling.osmFISH_dots_thr_selection.counting_graph"><code class="name flex">
<span>def <span class="ident">counting_graph</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def counting_graph(self):

    # Define the range of thr to be tested
    if self.min_int and self.max_int:
        self.thr_array = np.linspace(self.min_int,self.max_int,num=100)
    elif self.min_int:
        self.thr_array = np.linspace(self.min_int,self.img.max(),num=100)
    elif self.max_int:
        self.thr_array = np.linspace(self.img.min(),self.max_int,num=100)
    else:
        self.thr_array = np.linspace(self.img.min(),self.img.max(),num=100)

    # Calculate the number of peaks for each threshold. In this calculation
    # the size of the objects is not considered
    self.peak_counter_min = 0
    self.peak_counter_max = 0
    for vl, thr in enumerate(self.thr_array):
        # The border is excluded from the counting
        self.peaks = feature.peak_local_max(self.img,min_distance=self.min_distance,\
            threshold_abs=thr,exclude_border=False, indices=True,\
            num_peaks=np.inf, footprint=None,labels=None)
        
        self.number_peaks = len(self.peaks)

        # Stop the counting when the number of peaks detected falls below 3
        if self.number_peaks&lt;=self.min_peaks:
            self.stop_thr = thr # Move in the upper loop so you will stop at the previous thr
            break
        else:
            self.total_peaks.append(len(self.peaks))
            self.thr_used.append(thr)</code></pre>
</details>
</dd>
<dt id="pysmFISH.dots_calling.osmFISH_dots_thr_selection.thr_identification"><code class="name flex">
<span>def <span class="ident">thr_identification</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def thr_identification(self):  
    # Consider the case of no detectected peaks or if there is only one Thr
    # that create peaks (list total_peaks have only one element and )
    # if np.array(total_peaks).sum()&gt;0 or len(total_peaks)&gt;1:
    if len(self.total_peaks)&gt;1:

        # Trim the threshold array in order to match the stopping point
        # used the [0][0] to get the first number and then take it out from list
        # thr_array = thr_array[:np.where(thr_array==stop_thr)[0][0]]
        self.thr_array = np.array(self.thr_used)

        # Calculate the gradient of the number of peaks distribution
        grad = np.gradient(self.total_peaks)
        
        # Restructure the data in order to avoid to consider the min_peak in the
        # calculations

        # Coord of the gradient min_peak
        grad_min_peak_coord = np.argmin(grad)
        
        # Trim the data to remove the peak.
        self.trimmed_thr_array = self.thr_array[grad_min_peak_coord:]
        self.trimmed_grad = grad[grad_min_peak_coord:]

        if self.trimmed_thr_array.shape&gt;(1,):

            # Trim the coords array in order to maintain the same length of the 
            # tr and pk
            self.trimmed_total_peaks = self.total_peaks[grad_min_peak_coord:]

            # To determine the threshold we will determine the Thr with the biggest
            # distance to the segment that join the end points of the calculated
            # gradient

            # Distances list
            distances = []

            # Calculate the coords of the end points of the gradient
            p1 = Point(self.trimmed_thr_array[0],self.trimmed_grad[0])
            p2 = Point(self.trimmed_thr_array[-1],self.trimmed_grad[-1])
            
            # Create a line that join the points
            s = Line(p1,p2)
            allpoints = np.arange(0,len(self.trimmed_thr_array))
            
            # Calculate the distance between all points and the line
            for p in allpoints:
                dst = s.distance(Point(self.trimmed_thr_array[p],self.trimmed_grad[p]))
                distances.append(dst.evalf())

            # Remove the end points from the lists
            self.trimmed_thr_array = self.trimmed_thr_array[1:-1]
            self.trimmed_grad = self.trimmed_grad[1:-1]
            self.trimmed_total_peaks = self.trimmed_total_peaks[1:-1]
            self.trimmed_distances = distances[1:-1]
        
            # Determine the coords of the selected Thr
            # Converted trimmed_distances to array because it crashed
            # on Sanger.
            if self.trimmed_distances: # Most efficient way will be to consider the length of Thr list
                thr_idx = np.argmax(np.array(self.trimmed_distances))
                self.selected_thr = self.trimmed_thr_array[thr_idx]
                # The selected threshold usually causes oversampling of the number of dots
                # I added a stringency parameter (int n) to use to select the Thr+n 
                # for the counting. It selects a stringency only if the trimmed_thr_array
                # is long enough. Also consider the case in which the stringency in negative
            else:
                self.selected_thr = self.fill_value
                self.trimmed_thr_array = self.fill_value
        else:
            self.selected_thr = self.fill_value
            self.trimmed_thr_array = self.fill_value
    else:
        self.selected_thr = self.fill_value
        self.trimmed_thr_array = self.fill_value</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pysmFISH" href="index.html">pysmFISH</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pysmFISH.dots_calling.osmFISH_peak_based_detection" href="#pysmFISH.dots_calling.osmFISH_peak_based_detection">osmFISH_peak_based_detection</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pysmFISH.dots_calling.osmFISH_dots_mapping" href="#pysmFISH.dots_calling.osmFISH_dots_mapping">osmFISH_dots_mapping</a></code></h4>
</li>
<li>
<h4><code><a title="pysmFISH.dots_calling.osmFISH_dots_thr_selection" href="#pysmFISH.dots_calling.osmFISH_dots_thr_selection">osmFISH_dots_thr_selection</a></code></h4>
<ul class="">
<li><code><a title="pysmFISH.dots_calling.osmFISH_dots_thr_selection.counting_graph" href="#pysmFISH.dots_calling.osmFISH_dots_thr_selection.counting_graph">counting_graph</a></code></li>
<li><code><a title="pysmFISH.dots_calling.osmFISH_dots_thr_selection.thr_identification" href="#pysmFISH.dots_calling.osmFISH_dots_thr_selection.thr_identification">thr_identification</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>