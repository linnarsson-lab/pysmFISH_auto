<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>pysmFISH.io API documentation</title>
<meta name="description" content="Module containing functions used to load and write data" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pysmFISH.io</code></h1>
</header>
<section id="section-intro">
<p>Module containing functions used to load and write data</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Module containing functions used to load and write data
&#34;&#34;&#34;

from typing import *
import zarr
import sys
import time
import numpy as np
import pandas as pd
from pathlib import Path
from dask import dataframe as dd
from dask.distributed import Client

from pysmFISH.utils import convert_from_uint16_to_float64
from pysmFISH.logger_utils import selected_logger


def create_empty_zarr_file(experiment_fpath:str,tag:str)-&gt; str:
    &#34;&#34;&#34;Function that create and empty zarr file 


    Args:
        experiment_fpath (str): location of the folder to be processed
        tag (str): string to add to the file name
    Returns:
        str: path of the created file
    &#34;&#34;&#34;
    

    experiment_fpath = Path(experiment_fpath)
    experiment_name = experiment_fpath.stem
    zarr_fpath = experiment_fpath / (experiment_name + &#39;_&#39; + tag + &#39;.zarr&#39;)
    
    store = zarr.DirectoryStore(zarr_fpath,&#39;w&#39;)
    grp = zarr.group(store=store)
    return zarr_fpath


def consolidate_zarr_metadata(parsed_raw_data_fpath: str):
    &#34;&#34;&#34;Function to consolidate all the zarr metadata in one unique
    json file for eady indexing and searching

    Args:
        parsed_raw_data_fpath (str): path to the zarr file for which
                    the metadata needs to be consolidated

    Returns:
        zarr groups instance with the consolidated metadata
    &#34;&#34;&#34;

    logger = selected_logger()
    try:
        store = zarr.DirectoryStore(parsed_raw_data_fpath)
        consolidated_grp = zarr.consolidate_metadata(store)
    except:
        logger.error(f&#39;cannot consolidate metadata of the parsed zarr file&#39;)
        sys.exit(f&#39;cannot consolidate metadata of the parsed zarr file&#39;)
    else:
        return consolidated_grp


def open_consolidated_metadata(parsed_raw_data_fpath:str):
    &#34;&#34;&#34;Load the consolidated json metadata file
    Args:
        parsed_raw_data_fpath (str): path to the zarr file with the
                consolidated metadata

    Returns:
        zarr groups instance with the consolidated metadata
    &#34;&#34;&#34;
    logger = selected_logger()
    
    try:
        store = zarr.DirectoryStore(parsed_raw_data_fpath)
    except:
        logger.error(f&#39;the metadata are not consolidated&#39;)
    else:
        consolidated_grp = zarr.open_consolidated(store)
        return consolidated_grp



def load_raw_images(zarr_grp_name:str,parsed_raw_data_fpath:str)-&gt;Tuple[np.ndarray,Dict]:
    &#34;&#34;&#34;Function used to load a raw image and metadata from the 
    parsed raw file and the attrs for the filtering

    Args:
        zarr_grp_name (str): name to the group to process. The group contain the raw images and the 
            corresponding metadata.
            grp = experiment_name_channel_fov_X
            dataset = raw_data_fov_X
        parsed_raw_data_fpath (str): fpath to zarr store containing the parsed raw images

    Returns:
        Tuple[np.ndarray,Dict]: return the selected image and the corresponding metadata
    &#34;&#34;&#34;
    logger = selected_logger()
    st = zarr.DirectoryStore(parsed_raw_data_fpath)
    root = zarr.group(store=st,overwrite=False)

    metadata = root[zarr_grp_name].attrs
    img = root[zarr_grp_name][metadata[&#39;fov_name&#39;]][...]

    return img, metadata



def load_general_zarr(fov_subdataset: pd.Series ,parsed_raw_data_fpath:str, tag:str)-&gt;Tuple[np.ndarray,Dict]:
    &#34;&#34;&#34;Function used to load images stored in a zarr file (ex. preprocessed zarr)

    Args:
        fov_subdataset (pd.Series): Dataset metadata corresponding to as specific fov
        parsed_raw_data_fpath (str): path to the zarr file
        tag (str): string used to specify the zarr file

    Returns:
         Tuple[np.ndarray,Dict]: return the selected image and the corresponding metadata
    &#34;&#34;&#34;
    logger = selected_logger()
    st = zarr.DirectoryStore(parsed_raw_data_fpath)
    root = zarr.group(store=st,overwrite=False)
    fov_name = tag + &#39;_fov_&#39; + str(fov_subdataset.fov_num)
    grp_name = fov_subdataset.experiment_name +&#39;_&#39; + fov_subdataset.channel + &#39;_round_&#39; + str(fov_subdataset.round_num) + &#39;_fov_&#39; + str(fov_subdataset.fov_num)
    img = root[grp_name][fov_name][...]
    img = convert_from_uint16_to_float64(img)
    metadata = root[grp_name].attrs
    return img, metadata



def simple_output_plotting(experiment_fpath: str, stitching_selected: str, 
                            selected_Hdistance: float, client, input_file_tag:str, file_tag: str):
    &#34;&#34;&#34;Utility function used to create a pandas dataframe with a simplified
    version of the eel analysis output that can be used for quick visualization

    Args:
        experiment_fpath (str): Path to the experiment to process
        stitching_selected (str): Define with stitched data will be selected
            for creating the simplified dataframe
        selected_Hdistance (float): Used to select the dots with hamming
            distance below this value (if selected_Hdistance is 0 plot the perfect barcodes )
        client (Client): Dask client taking care of the processing 
        input_file_tag (str): File type to load for the plotting
        file_tag (str): tag to label the output file
    &#34;&#34;&#34;

    experiment_fpath = Path(experiment_fpath)
    counts_dd = dd.read_parquet(experiment_fpath / &#39;results&#39; / (&#39;*&#39; + input_file_tag +&#39;*.parquet&#39;),engine=&#39;pyarrow&#39;)

    date_tag = time.strftime(&#34;%y%m%d_%H_%M_%S&#34;)

    r_tag = &#39;r_px_&#39; + stitching_selected
    c_tag = &#39;c_px_&#39; + stitching_selected

    if selected_Hdistance == 0:
        counts_dd_below  = counts_dd.loc[counts_dd.hamming_distance == selected_Hdistance, :]

    else:
        counts_dd_below  = counts_dd.loc[counts_dd.hamming_distance &lt; selected_Hdistance, :]

    counts_df = counts_dd_below.loc[:,[&#39;fov_num&#39;,r_tag,c_tag, &#39;decoded_genes&#39;]].compute()

    counts_df=counts_df.dropna(subset=[&#39;decoded_genes&#39;])
    fpath = experiment_fpath / &#39;results&#39; / (date_tag + &#39;_&#39; + experiment_fpath.stem + &#39;_data_summary_simple_plotting_&#39;+file_tag+&#39;.parquet&#39;)
    counts_df.to_parquet(fpath,index=False)


def simple_output_plotting_serial(experiment_fpath: str, stitching_selected: str, 
                                client,file_tag: str):
    &#34;&#34;&#34;Utility function used to create a pandas dataframe with a simplified
    version of the serial analysis output that can be used for quick visualization

    Args:
        experiment_fpath (str): Path to the experiment to process
        stitching_selected (str): Define with stitched data will be selected
            for creating the simplified dataframe
        client (Client): Dask client taking care of the processing 
        file_tag (str): tag to label the output file

    &#34;&#34;&#34;


    experiment_fpath = Path(experiment_fpath)
    counts_dd = dd.read_parquet(experiment_fpath / &#39;results&#39; / (&#39;*&#39;+file_tag+&#39;*.parquet&#39;),engine=&#39;pyarrow&#39;)

    date_tag = time.strftime(&#34;%y%m%d_%H_%M_%S&#34;)

    r_tag = &#39;r_px_&#39; + stitching_selected
    c_tag = &#39;c_px_&#39; + stitching_selected


    counts_df = counts_dd.loc[:,[&#39;fov_num&#39;,r_tag,c_tag, &#39;target_name&#39;]].compute()

    counts_df=counts_df.dropna(subset=[&#39;target_name&#39;])
    fpath = experiment_fpath / &#39;results&#39; / (date_tag + &#39;_&#39; + experiment_fpath.stem + &#39;_data_summary_simple_plotting_&#39;+file_tag+&#39;.parquet&#39;)
    counts_df.to_parquet(fpath,index=False)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pysmFISH.io.consolidate_zarr_metadata"><code class="name flex">
<span>def <span class="ident">consolidate_zarr_metadata</span></span>(<span>parsed_raw_data_fpath: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to consolidate all the zarr metadata in one unique
json file for eady indexing and searching</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parsed_raw_data_fpath</code></strong> :&ensp;<code>str</code></dt>
<dd>path to the zarr file for which
the metadata needs to be consolidated</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>zarr groups instance with the consolidated metadata</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def consolidate_zarr_metadata(parsed_raw_data_fpath: str):
    &#34;&#34;&#34;Function to consolidate all the zarr metadata in one unique
    json file for eady indexing and searching

    Args:
        parsed_raw_data_fpath (str): path to the zarr file for which
                    the metadata needs to be consolidated

    Returns:
        zarr groups instance with the consolidated metadata
    &#34;&#34;&#34;

    logger = selected_logger()
    try:
        store = zarr.DirectoryStore(parsed_raw_data_fpath)
        consolidated_grp = zarr.consolidate_metadata(store)
    except:
        logger.error(f&#39;cannot consolidate metadata of the parsed zarr file&#39;)
        sys.exit(f&#39;cannot consolidate metadata of the parsed zarr file&#39;)
    else:
        return consolidated_grp</code></pre>
</details>
</dd>
<dt id="pysmFISH.io.create_empty_zarr_file"><code class="name flex">
<span>def <span class="ident">create_empty_zarr_file</span></span>(<span>experiment_fpath: str, tag: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Function that create and empty zarr file </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>experiment_fpath</code></strong> :&ensp;<code>str</code></dt>
<dd>location of the folder to be processed</dd>
<dt><strong><code>tag</code></strong> :&ensp;<code>str</code></dt>
<dd>string to add to the file name</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>path of the created file</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_empty_zarr_file(experiment_fpath:str,tag:str)-&gt; str:
    &#34;&#34;&#34;Function that create and empty zarr file 


    Args:
        experiment_fpath (str): location of the folder to be processed
        tag (str): string to add to the file name
    Returns:
        str: path of the created file
    &#34;&#34;&#34;
    

    experiment_fpath = Path(experiment_fpath)
    experiment_name = experiment_fpath.stem
    zarr_fpath = experiment_fpath / (experiment_name + &#39;_&#39; + tag + &#39;.zarr&#39;)
    
    store = zarr.DirectoryStore(zarr_fpath,&#39;w&#39;)
    grp = zarr.group(store=store)
    return zarr_fpath</code></pre>
</details>
</dd>
<dt id="pysmFISH.io.load_general_zarr"><code class="name flex">
<span>def <span class="ident">load_general_zarr</span></span>(<span>fov_subdataset: pandas.core.series.Series, parsed_raw_data_fpath: str, tag: str) ‑> Tuple[numpy.ndarray, Dict]</span>
</code></dt>
<dd>
<div class="desc"><p>Function used to load images stored in a zarr file (ex. preprocessed zarr)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>fov_subdataset</code></strong> :&ensp;<code>pd.Series</code></dt>
<dd>Dataset metadata corresponding to as specific fov</dd>
<dt><strong><code>parsed_raw_data_fpath</code></strong> :&ensp;<code>str</code></dt>
<dd>path to the zarr file</dd>
<dt><strong><code>tag</code></strong> :&ensp;<code>str</code></dt>
<dd>string used to specify the zarr file</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[np.ndarray,Dict]</code></dt>
<dd>return the selected image and the corresponding metadata</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_general_zarr(fov_subdataset: pd.Series ,parsed_raw_data_fpath:str, tag:str)-&gt;Tuple[np.ndarray,Dict]:
    &#34;&#34;&#34;Function used to load images stored in a zarr file (ex. preprocessed zarr)

    Args:
        fov_subdataset (pd.Series): Dataset metadata corresponding to as specific fov
        parsed_raw_data_fpath (str): path to the zarr file
        tag (str): string used to specify the zarr file

    Returns:
         Tuple[np.ndarray,Dict]: return the selected image and the corresponding metadata
    &#34;&#34;&#34;
    logger = selected_logger()
    st = zarr.DirectoryStore(parsed_raw_data_fpath)
    root = zarr.group(store=st,overwrite=False)
    fov_name = tag + &#39;_fov_&#39; + str(fov_subdataset.fov_num)
    grp_name = fov_subdataset.experiment_name +&#39;_&#39; + fov_subdataset.channel + &#39;_round_&#39; + str(fov_subdataset.round_num) + &#39;_fov_&#39; + str(fov_subdataset.fov_num)
    img = root[grp_name][fov_name][...]
    img = convert_from_uint16_to_float64(img)
    metadata = root[grp_name].attrs
    return img, metadata</code></pre>
</details>
</dd>
<dt id="pysmFISH.io.load_raw_images"><code class="name flex">
<span>def <span class="ident">load_raw_images</span></span>(<span>zarr_grp_name: str, parsed_raw_data_fpath: str) ‑> Tuple[numpy.ndarray, Dict]</span>
</code></dt>
<dd>
<div class="desc"><p>Function used to load a raw image and metadata from the
parsed raw file and the attrs for the filtering</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>zarr_grp_name</code></strong> :&ensp;<code>str</code></dt>
<dd>name to the group to process. The group contain the raw images and the
corresponding metadata.
grp = experiment_name_channel_fov_X
dataset = raw_data_fov_X</dd>
<dt><strong><code>parsed_raw_data_fpath</code></strong> :&ensp;<code>str</code></dt>
<dd>fpath to zarr store containing the parsed raw images</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[np.ndarray,Dict]</code></dt>
<dd>return the selected image and the corresponding metadata</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_raw_images(zarr_grp_name:str,parsed_raw_data_fpath:str)-&gt;Tuple[np.ndarray,Dict]:
    &#34;&#34;&#34;Function used to load a raw image and metadata from the 
    parsed raw file and the attrs for the filtering

    Args:
        zarr_grp_name (str): name to the group to process. The group contain the raw images and the 
            corresponding metadata.
            grp = experiment_name_channel_fov_X
            dataset = raw_data_fov_X
        parsed_raw_data_fpath (str): fpath to zarr store containing the parsed raw images

    Returns:
        Tuple[np.ndarray,Dict]: return the selected image and the corresponding metadata
    &#34;&#34;&#34;
    logger = selected_logger()
    st = zarr.DirectoryStore(parsed_raw_data_fpath)
    root = zarr.group(store=st,overwrite=False)

    metadata = root[zarr_grp_name].attrs
    img = root[zarr_grp_name][metadata[&#39;fov_name&#39;]][...]

    return img, metadata</code></pre>
</details>
</dd>
<dt id="pysmFISH.io.open_consolidated_metadata"><code class="name flex">
<span>def <span class="ident">open_consolidated_metadata</span></span>(<span>parsed_raw_data_fpath: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Load the consolidated json metadata file</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parsed_raw_data_fpath</code></strong> :&ensp;<code>str</code></dt>
<dd>path to the zarr file with the
consolidated metadata</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>zarr groups instance with the consolidated metadata</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open_consolidated_metadata(parsed_raw_data_fpath:str):
    &#34;&#34;&#34;Load the consolidated json metadata file
    Args:
        parsed_raw_data_fpath (str): path to the zarr file with the
                consolidated metadata

    Returns:
        zarr groups instance with the consolidated metadata
    &#34;&#34;&#34;
    logger = selected_logger()
    
    try:
        store = zarr.DirectoryStore(parsed_raw_data_fpath)
    except:
        logger.error(f&#39;the metadata are not consolidated&#39;)
    else:
        consolidated_grp = zarr.open_consolidated(store)
        return consolidated_grp</code></pre>
</details>
</dd>
<dt id="pysmFISH.io.simple_output_plotting"><code class="name flex">
<span>def <span class="ident">simple_output_plotting</span></span>(<span>experiment_fpath: str, stitching_selected: str, selected_Hdistance: float, client, input_file_tag: str, file_tag: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Utility function used to create a pandas dataframe with a simplified
version of the eel analysis output that can be used for quick visualization</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>experiment_fpath</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the experiment to process</dd>
<dt><strong><code>stitching_selected</code></strong> :&ensp;<code>str</code></dt>
<dd>Define with stitched data will be selected
for creating the simplified dataframe</dd>
<dt><strong><code>selected_Hdistance</code></strong> :&ensp;<code>float</code></dt>
<dd>Used to select the dots with hamming
distance below this value (if selected_Hdistance is 0 plot the perfect barcodes )</dd>
<dt><strong><code>client</code></strong> :&ensp;<code>Client</code></dt>
<dd>Dask client taking care of the processing </dd>
<dt><strong><code>input_file_tag</code></strong> :&ensp;<code>str</code></dt>
<dd>File type to load for the plotting</dd>
<dt><strong><code>file_tag</code></strong> :&ensp;<code>str</code></dt>
<dd>tag to label the output file</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simple_output_plotting(experiment_fpath: str, stitching_selected: str, 
                            selected_Hdistance: float, client, input_file_tag:str, file_tag: str):
    &#34;&#34;&#34;Utility function used to create a pandas dataframe with a simplified
    version of the eel analysis output that can be used for quick visualization

    Args:
        experiment_fpath (str): Path to the experiment to process
        stitching_selected (str): Define with stitched data will be selected
            for creating the simplified dataframe
        selected_Hdistance (float): Used to select the dots with hamming
            distance below this value (if selected_Hdistance is 0 plot the perfect barcodes )
        client (Client): Dask client taking care of the processing 
        input_file_tag (str): File type to load for the plotting
        file_tag (str): tag to label the output file
    &#34;&#34;&#34;

    experiment_fpath = Path(experiment_fpath)
    counts_dd = dd.read_parquet(experiment_fpath / &#39;results&#39; / (&#39;*&#39; + input_file_tag +&#39;*.parquet&#39;),engine=&#39;pyarrow&#39;)

    date_tag = time.strftime(&#34;%y%m%d_%H_%M_%S&#34;)

    r_tag = &#39;r_px_&#39; + stitching_selected
    c_tag = &#39;c_px_&#39; + stitching_selected

    if selected_Hdistance == 0:
        counts_dd_below  = counts_dd.loc[counts_dd.hamming_distance == selected_Hdistance, :]

    else:
        counts_dd_below  = counts_dd.loc[counts_dd.hamming_distance &lt; selected_Hdistance, :]

    counts_df = counts_dd_below.loc[:,[&#39;fov_num&#39;,r_tag,c_tag, &#39;decoded_genes&#39;]].compute()

    counts_df=counts_df.dropna(subset=[&#39;decoded_genes&#39;])
    fpath = experiment_fpath / &#39;results&#39; / (date_tag + &#39;_&#39; + experiment_fpath.stem + &#39;_data_summary_simple_plotting_&#39;+file_tag+&#39;.parquet&#39;)
    counts_df.to_parquet(fpath,index=False)</code></pre>
</details>
</dd>
<dt id="pysmFISH.io.simple_output_plotting_serial"><code class="name flex">
<span>def <span class="ident">simple_output_plotting_serial</span></span>(<span>experiment_fpath: str, stitching_selected: str, client, file_tag: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Utility function used to create a pandas dataframe with a simplified
version of the serial analysis output that can be used for quick visualization</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>experiment_fpath</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the experiment to process</dd>
<dt><strong><code>stitching_selected</code></strong> :&ensp;<code>str</code></dt>
<dd>Define with stitched data will be selected
for creating the simplified dataframe</dd>
<dt><strong><code>client</code></strong> :&ensp;<code>Client</code></dt>
<dd>Dask client taking care of the processing </dd>
<dt><strong><code>file_tag</code></strong> :&ensp;<code>str</code></dt>
<dd>tag to label the output file</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simple_output_plotting_serial(experiment_fpath: str, stitching_selected: str, 
                                client,file_tag: str):
    &#34;&#34;&#34;Utility function used to create a pandas dataframe with a simplified
    version of the serial analysis output that can be used for quick visualization

    Args:
        experiment_fpath (str): Path to the experiment to process
        stitching_selected (str): Define with stitched data will be selected
            for creating the simplified dataframe
        client (Client): Dask client taking care of the processing 
        file_tag (str): tag to label the output file

    &#34;&#34;&#34;


    experiment_fpath = Path(experiment_fpath)
    counts_dd = dd.read_parquet(experiment_fpath / &#39;results&#39; / (&#39;*&#39;+file_tag+&#39;*.parquet&#39;),engine=&#39;pyarrow&#39;)

    date_tag = time.strftime(&#34;%y%m%d_%H_%M_%S&#34;)

    r_tag = &#39;r_px_&#39; + stitching_selected
    c_tag = &#39;c_px_&#39; + stitching_selected


    counts_df = counts_dd.loc[:,[&#39;fov_num&#39;,r_tag,c_tag, &#39;target_name&#39;]].compute()

    counts_df=counts_df.dropna(subset=[&#39;target_name&#39;])
    fpath = experiment_fpath / &#39;results&#39; / (date_tag + &#39;_&#39; + experiment_fpath.stem + &#39;_data_summary_simple_plotting_&#39;+file_tag+&#39;.parquet&#39;)
    counts_df.to_parquet(fpath,index=False)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pysmFISH" href="index.html">pysmFISH</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pysmFISH.io.consolidate_zarr_metadata" href="#pysmFISH.io.consolidate_zarr_metadata">consolidate_zarr_metadata</a></code></li>
<li><code><a title="pysmFISH.io.create_empty_zarr_file" href="#pysmFISH.io.create_empty_zarr_file">create_empty_zarr_file</a></code></li>
<li><code><a title="pysmFISH.io.load_general_zarr" href="#pysmFISH.io.load_general_zarr">load_general_zarr</a></code></li>
<li><code><a title="pysmFISH.io.load_raw_images" href="#pysmFISH.io.load_raw_images">load_raw_images</a></code></li>
<li><code><a title="pysmFISH.io.open_consolidated_metadata" href="#pysmFISH.io.open_consolidated_metadata">open_consolidated_metadata</a></code></li>
<li><code><a title="pysmFISH.io.simple_output_plotting" href="#pysmFISH.io.simple_output_plotting">simple_output_plotting</a></code></li>
<li><code><a title="pysmFISH.io.simple_output_plotting_serial" href="#pysmFISH.io.simple_output_plotting_serial">simple_output_plotting_serial</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>