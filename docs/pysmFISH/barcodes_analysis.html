<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>pysmFISH.barcodes_analysis API documentation</title>
<meta name="description" content="Function and classes used to identify barcodes" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pysmFISH.barcodes_analysis</code></h1>
</header>
<section id="section-intro">
<p>Function and classes used to identify barcodes</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Function and classes used to identify barcodes
&#34;&#34;&#34;
from typing import *
import pandas as pd
import numpy as np
import pickle
import logging
from sklearn.neighbors import NearestNeighbors
# from pynndescent import NNDescent
from pathlib import Path
from itertools import groupby

from pysmFISH.logger_utils import selected_logger
from pysmFISH.data_models import Output_models
from pysmFISH.errors import Registration_errors


class simplify_barcodes_reference():
    &#34;&#34;&#34;Utility Class use to convert excels files with codebook info
    in smaller size pandas dataframe/parquet files to pass to dask
    workers during the processing. This utility function must be
    run before running the experiment analysis. The pipeline
    require the output of this function.
    &#34;&#34;&#34;
    
    def __init__(self, barcode_fpath: str):
        &#34;&#34;&#34;Class initialization

        Args:
            barcode_fpath (str): Path to the xlsx file with the codebook
        &#34;&#34;&#34;
        
        self.barcode_fpath = Path(barcode_fpath)
        self.barcode_fname = self.barcode_fpath.stem

    @staticmethod
    def format_codeword(codeword: str):
        &#34;&#34;&#34;[summary]

        Args:
            codeword (str): codeword representing a gene

        Returns:
            byte: codeword converted in byte representation
        &#34;&#34;&#34;
        str_num = codeword.split(&#39;[&#39;)[-1].split(&#39;]&#39;)[0]
        converted_codeword = np.array([int(el) for el in list(str_num)]).astype(np.int8)
        converted_codeword = converted_codeword.tobytes()
        return converted_codeword

    def convert_codebook(self):
        used_gene_codebook_df = pd.read_excel(self.barcode_fpath)
        # used_gene_codebook_df = pd.read_parquet(self.barcode_fpath)
        self.codebook_df = used_gene_codebook_df.loc[:,[&#39;Barcode&#39;,&#39;Gene&#39;]]
        self.codebook_df.rename(columns = {&#39;Barcode&#39;:&#39;Code&#39;}, inplace = True)
        self.codebook_df.Code = self.codebook_df.Code.apply(lambda x: self.format_codeword(x))
        self.codebook_df.to_parquet(self.barcode_fpath.parent / (self.barcode_fname + &#39;.parquet&#39;))



def dots_hoods(coords: np.ndarray,pxl: int)-&gt;np.ndarray:
    &#34;&#34;&#34;Function that calculate the coords of the peaks searching
    neighborhood for identifying the barcodes.

    Args:
        coords (np.ndarray): coords of the identified peaks
        pxl (int): size of the neighborhood in pixel

    Returns:
        np.ndarray: coords that define the neighborhood (r_tl,r_br,c_tl,c_tr)
    &#34;&#34;&#34;
    r_tl = coords[:,0]-pxl
    r_br = coords[:,0]+pxl
    c_tl = coords[:,1]-pxl
    c_tr = coords[:,1]+pxl
    r_tl = r_tl[:,np.newaxis]
    r_br = r_br[:,np.newaxis]
    c_tl = c_tl[:,np.newaxis]
    c_tr = c_tr[:,np.newaxis]
    chunks_coords = np.hstack((r_tl,r_br,c_tl,c_tr))
    chunks_coords = chunks_coords.astype(int)
    return chunks_coords


def extract_dots_images(barcoded_df: pd.DataFrame,registered_img_stack: np.ndarray,
                experiment_fpath: str, metadata: dict):
    &#34;&#34;&#34;Function used to extract the images corresponding to a barcode
    after running the decoding identification. It can save the images
    but to avoid increasing too much the space occupied by a processed
    experiment an array with the maximum intensity value of the pxl in
    each round is calculated and saved 

    Args:
        barcoded_df (pd.DataFrame): Dataframe with decoded barcodes 
                    for a specific field of view.
        registered_img_stack (np.ndarray): Preprocessed image of a single field of view
                    the imaging round correspond to the z-stack position
        experiment_fpath (str): Path to the folder of the experiment to process
        metadata (dict): Overall experiment info
    &#34;&#34;&#34;
    
    round_intensity_labels = [&#39;bit_&#39; + str(el) +&#39;_intensity&#39; for el in np.arange(1,int(metadata[&#39;total_rounds&#39;])+1)]
    
    if isinstance(registered_img_stack, np.ndarray) and (barcoded_df.shape[0] &gt;1):
        experiment_fpath = Path(experiment_fpath)
          
        barcodes_names = barcoded_df[&#39;barcode_reference_dot_id&#39;].values
        coords = barcoded_df.loc[:, [&#39;r_px_registered&#39;, &#39;c_px_registered&#39;]].to_numpy()
        barcodes_extraction_resolution = barcoded_df[&#39;barcodes_extraction_resolution&#39;].values[0]

        chunks_coords = dots_hoods(coords,barcodes_extraction_resolution)
        chunks_coords[chunks_coords&lt;0]=0
        chunks_coords[chunks_coords&gt;registered_img_stack.shape[1]]= registered_img_stack.shape[1]
    
        for idx in np.arange(chunks_coords.shape[0]):
            selected_region = registered_img_stack[:,chunks_coords[idx,0]:chunks_coords[idx,1]+1,chunks_coords[idx,2]:chunks_coords[idx,3]+1]
            if selected_region.size &gt;0:
                max_array = selected_region.max(axis=(1,2))
                barcoded_df.loc[barcoded_df.dot_id == barcodes_names[idx],round_intensity_labels] = max_array


        # for channel in channels:
            # all_regions[channel] = {}
            # all_max[channel] = {}
            # img_stack = registered_img_stack[channel]
            # trimmed_df_channel = trimmed_df.loc[trimmed_df.channel == channel]
            # if trimmed_df_channel.shape[0] &gt;0:

            #     barcodes_names = trimmed_df_channel[&#39;barcode_reference_dot_id&#39;].values
            #     coords = trimmed_df_channel.loc[:, [&#39;r_px_registered&#39;, &#39;c_px_registered&#39;]].to_numpy()
            #     barcodes_extraction_resolution = trimmed_df_channel[&#39;barcodes_extraction_resolution&#39;].values[0]

            #     chunks_coords = dots_hoods(coords,barcodes_extraction_resolution)
            #     chunks_coords[chunks_coords&lt;0]=0
            #     chunks_coords[chunks_coords&gt;img_stack.shape[1]]= img_stack.shape[1]
            
            
            #     for idx in np.arange(chunks_coords.shape[0]):
            #         selected_region = img_stack[:,chunks_coords[idx,0]:chunks_coords[idx,1]+1,chunks_coords[idx,2]:chunks_coords[idx,3]+1]
            #         if selected_region.size &gt;0:
            #             max_array = selected_region.max(axis=(1,2))
            #             # all_regions[channel][barcodes_names[idx]]= selected_region
            #             all_max[channel][barcodes_names[idx]]= max_array
            #             barcoded_df.loc[barcoded_df.dot_id == barcodes_names[idx],round_intensity_labels] = max_array

        # fpath = experiment_fpath / &#39;tmp&#39; / &#39;combined_rounds_images&#39; / (experiment_name + &#39;_&#39; + channel + &#39;_img_dict_fov_&#39; + str(fov) + &#39;.pkl&#39;)
        # pickle.dump(all_regions,open(fpath,&#39;wb&#39;))
        # fpath = experiment_fpath / &#39;results&#39; / (experiment_name + &#39;_barcodes_max_array_dict_fov_&#39; + str(fov) + &#39;.pkl&#39;)
        # pickle.dump(all_max,open(fpath,&#39;wb&#39;))
    
    else:
        barcoded_df.loc[:,round_intensity_labels] = np.nan
    
    return barcoded_df









def identify_flipped_bits(codebook: pd.DataFrame, gene: str, 
                    raw_barcode: ByteString)-&gt; Tuple[ByteString, ByteString]:
    &#34;&#34;&#34;Utility function used to identify the position of the bits that are
    flipped after the nearest neighbors and the definition of the
    acceptable hamming distance for a single dot.

    Args:
        codebook (pd.DataFrame): Codebook used for the decoding
        gene (str): Name of the gene identified
        raw_barcode (ByteString): identifide barcode from the images

    Returns:
        Tuple[ByteString, ByteString]: (flipped_position, flipping_direction)
    &#34;&#34;&#34;
    gene_barcode_str =codebook.loc[codebook.Gene == gene, &#39;Code&#39;].values[0]
    gene_barcode = np.frombuffer(gene_barcode_str, np.int8)
    raw_barcode = np.frombuffer(raw_barcode, np.int8)
    flipped_positions = np.where(raw_barcode != gene_barcode)[0].astype(np.int8)
    flipping_directions = (gene_barcode[flipped_positions] - raw_barcode[flipped_positions]).astype(np.int8)
    # flipped_positions = flipped_positions.tobytes()
    # flipping_directions = flipping_directions.tobytes()
    return flipped_positions,flipping_directions


def define_flip_direction(codebook_dict: dict,experiment_fpath: str, 
            output_df: pd.DataFrame):
    &#34;&#34;&#34;Function used to determinethe the position of the bits that are
    flipped after the nearest neighbors and the definition of the
    acceptable hamming distance for fov.

    Args:
        codebook (dict): Codebooks used for the decoding
        experiment_fpath (str): Path to the folder of the experiment to process
        output_df (pd.DataFrame): Dataframe with the decoded results for 
                    the specific fov.
    &#34;&#34;&#34;
    if output_df.shape[0] &gt; 1:
        correct_hamming_distance = 0
        selected_hamming_distance = 3 / output_df.iloc[0].barcode_length
        experiment_fpath = Path(experiment_fpath)
        experiment_name = experiment_fpath.stem
        channels = codebook_dict.keys()
        all_evaluated = []
        for channel in channels: 
            codebook = codebook_dict[channel]
            fov = output_df.fov_num.values[0]
            trimmed_df = output_df.loc[(output_df.dot_id == output_df.barcode_reference_dot_id) &amp;
                                (output_df.channel == channel) &amp;
                                (output_df[&#39;hamming_distance&#39;] &gt; correct_hamming_distance) &amp;
                                (output_df[&#39;hamming_distance&#39;] &lt; selected_hamming_distance),
                                    [&#39;barcode_reference_dot_id&#39;, &#39;decoded_genes&#39;, &#39;raw_barcodes&#39;,&#39;hamming_distance&#39;]]
            trimmed_df = trimmed_df.dropna(subset=[&#39;decoded_genes&#39;])
            trimmed_df.loc[:,(&#39;flip_and_direction&#39;)] = trimmed_df.apply(lambda x: identify_flipped_bits(codebook,x.decoded_genes,x.raw_barcodes),axis=1)
            trimmed_df[&#39;flip_position&#39;] = trimmed_df[&#39;flip_and_direction&#39;].apply(lambda x: x[0])
            trimmed_df[&#39;flip_direction&#39;] = trimmed_df[&#39;flip_and_direction&#39;].apply(lambda x: x[1])
            trimmed_df.drop(columns=[&#39;flip_and_direction&#39;],inplace=True)
            all_evaluated.append(trimmed_df)
        
        all_evaluated = pd.concat(all_evaluated,axis=0,ignore_index=True,inplace=True)

        
        fpath = experiment_fpath / &#39;results&#39; / (experiment_name + &#39;_&#39; + channel + &#39;_df_flip_direction_fov&#39; + str(fov) + &#39;.parquet&#39;)
        all_evaluated.to_parquet(fpath)
        # return trimmed_df


def chunk_dfs(dataframes_list: list, chunk_size: int):
    &#34;&#34;&#34; 
    Functions modified from
    https://stackoverflow.com/questions/45217120/how-to-efficiently-join-merge-concatenate-large-data-frame-in-pandas
    yields n dataframes at a time where n == chunksize 
    &#34;&#34;&#34;
    dfs = []
    for f in dataframes_list:
        dfs.append(f)
        if len(dfs) == chunk_size:
            yield dfs
            dfs  = []
    if dfs:
        yield dfs


def merge_with_concat(dfs: list)-&gt;pd.DataFrame:
    &#34;&#34;&#34;Utility function used to merge dataframes

    Args:
        dsf (list): List with the dataframe to merge

    Returns:
        pd.DataFrame: Merged dataframe
    &#34;&#34;&#34;                                           

#     dfs = (df.set_index(col, drop=True) for df in dfs)
    merged = pd.concat(dfs, axis=0, join=&#39;outer&#39;, copy=False)
    return merged


&#34;&#34;&#34;
    Class used to extract the barcodes from the registered
    counts using nearest neighbour

    Parameters:
    -----------
    counts: pandas.DataFrame
        pandas file with the fov counts after
        registration
    analysis_parameters: dict
        parameters for data processing 
    codebook_df: pandas.DataFrame
        pandas file with the codebook used to
        deconvolve the barcode

    NB: if there is a problem with the registration the barcode assigned 
        will be 0*barcode_length
    
    &#34;&#34;&#34;


def extract_barcodes_NN_fast_multicolor(registered_counts_df: pd.DataFrame, analysis_parameters: Dict,
                codebook_df: pd.DataFrame, metadata:dict)-&gt; Tuple[pd.DataFrame,pd.DataFrame]:
    &#34;&#34;&#34;Function used to extract the barcodes from the registered
    counts using nearest neighbour. if there is a problem with the registration the barcode assigned 
    will be 0*barcode_length

    Args:
        registered_counts_df (pd.Dataframe): Fov counts after registration
        analysis_parameters (Dict): Parameters for data processing 
        codebook_df (pd.DataFrame): codebook used to deconvolve the barcode
    Returns:
        Tuple[pd.DataFrame,pd.DataFrame]: (barcoded_round, all_decoded_dots_df)
    &#34;&#34;&#34;

    logger = selected_logger()

    barcodes_extraction_resolution = analysis_parameters[&#39;BarcodesExtractionResolution&#39;]
    RegistrationMinMatchingBeads = analysis_parameters[&#39;RegistrationMinMatchingBeads&#39;]
    barcode_length = metadata[&#39;barcode_length&#39;]
    registration_errors = Registration_errors()

    stitching_channel = metadata[&#39;stitching_channel&#39;]
    
 
    registered_counts_df.dropna(subset=[&#39;dot_id&#39;],inplace=True)
    # Starting level for selection of dots
    dropping_counts = registered_counts_df.copy(deep=True)

    all_decoded_dots_list = []
    barcoded_round = []
    if registered_counts_df[&#39;r_px_registered&#39;].isnull().values.any():
        
        all_decoded_dots_df = pd.DataFrame(columns = registered_counts_df.columns)
        all_decoded_dots_df[&#39;decoded_genes&#39;] = np.nan
        all_decoded_dots_df[&#39;hamming_distance&#39;] = np.nan
        all_decoded_dots_df[&#39;number_positive_bits&#39;] = np.nan
        all_decoded_dots_df[&#39;barcode_reference_dot_id&#39;] = np.nan
        all_decoded_dots_df[&#39;raw_barcodes&#39;] = np.nan
        all_decoded_dots_df[&#39;barcodes_extraction_resolution&#39;] = barcodes_extraction_resolution
        # Save barcoded_round and all_decoded_dots_df
        return registered_counts_df, all_decoded_dots_df
        
    else:
        for ref_round_number in np.arange(1,barcode_length+1):

            #ref_round_number = 1
            reference_round_df = dropping_counts.loc[dropping_counts.round_num == ref_round_number,:]
            # Step one (all dots not in round 1)
            compare_df = dropping_counts.loc[dropping_counts.round_num!=ref_round_number,:]

            if (not reference_round_df.empty):
                if not compare_df.empty:
                    nn = NearestNeighbors(n_neighbors=1, metric=&#34;euclidean&#34;)
                    nn.fit(reference_round_df[[&#39;r_px_registered&#39;,&#39;c_px_registered&#39;]])
                    dists, indices = nn.kneighbors(compare_df[[&#39;r_px_registered&#39;,&#39;c_px_registered&#39;]], return_distance=True)

                    # select only the nn that are below barcodes_extraction_resolution distance
                    idx_distances_below_resolution = np.where(dists &lt;= barcodes_extraction_resolution)[0]

                    comp_idx = idx_distances_below_resolution
                    ref_idx = indices[comp_idx].flatten()

                    # Subset the dataframe according to the selected points
                    # The reference selected will have repeated points
                    comp_selected_df = compare_df.iloc[comp_idx]
                    ref_selected_df = reference_round_df.iloc[ref_idx]

                    # The size of ref_selected_df w/o duplicates may be smaller of reference_round_df if 
                    # some of the dots in reference_round_df have no neighbours

                    # Test approach where we get rid of the single dots
                    comp_selected_df.loc[:,&#39;barcode_reference_dot_id&#39;] = ref_selected_df[&#39;dot_id&#39;].values
                    ref_selected_df_no_duplicates = ref_selected_df.drop_duplicates()
                    ref_selected_df_no_duplicates.loc[:,&#39;barcode_reference_dot_id&#39;] = ref_selected_df_no_duplicates[&#39;dot_id&#39;].values

                    # Collect singletons
                    # Remeber that this method works only because there are no duplicates inside the dataframes
                    # https://stackoverflow.com/questions/48647534/python-pandas-find-difference-between-two-data-frames
                    if reference_round_df.shape[0] &gt; ref_selected_df_no_duplicates.shape[0]:
                        singletons_df = pd.concat([reference_round_df,ref_selected_df_no_duplicates]).drop_duplicates(keep=False)
                        singletons_df.loc[:,&#39;barcode_reference_dot_id&#39;] = singletons_df[&#39;dot_id&#39;].values
                        barcoded_round = pd.concat([comp_selected_df, ref_selected_df_no_duplicates,singletons_df], axis=0,ignore_index=False)
                    else:
                        barcoded_round = pd.concat([comp_selected_df, ref_selected_df_no_duplicates], axis=0,ignore_index=False)

                    barcoded_round = pd.concat([comp_selected_df, ref_selected_df_no_duplicates,singletons_df], axis=0,ignore_index=False)
                    barcoded_round_grouped = barcoded_round.groupby(&#39;barcode_reference_dot_id&#39;)

                    compare_df = compare_df.drop(comp_selected_df.index)
                    dropping_counts = compare_df

                else:
                    # Collecting singleton of last bit
                    reference_round_df.loc[:,&#39;barcode_reference_dot_id&#39;] = reference_round_df[&#39;dot_id&#39;].values
                    barcoded_round_grouped = reference_round_df.groupby(&#39;barcode_reference_dot_id&#39;)
                    ref_selected_df_no_duplicates = reference_round_df

                for brdi, grp in barcoded_round_grouped:
                    barcode = np.zeros([barcode_length],dtype=np.int8)
                    barcode[grp.round_num.values.astype(np.int8)-1] = 1
                    #hamming_dist, index_gene = nn_sklearn.kneighbors(barcode.reshape(1, -1), return_distance=True)
                    #gene= codebook_df.loc[index_gene.reshape(index_gene.shape[0]),&#39;Gene&#39;].tolist()

                    barcode = barcode.tostring()
                    if len(ref_selected_df_no_duplicates) !=  0:
                        ref_selected_df_no_duplicates.loc[ref_selected_df_no_duplicates.barcode_reference_dot_id == brdi,&#39;raw_barcodes&#39;] = barcode
                    #ref_selected_df_no_duplicates.loc[ref_selected_df_no_duplicates.barcode_reference_dot_id == brdi,&#39;decoded_gene_name&#39;] = gene
                    #ref_selected_df_no_duplicates.loc[ref_selected_df_no_duplicates.barcode_reference_dot_id == brdi,&#39;hamming_distance&#39;] = hamming_dist.flatten()[0]

                    #fish_counts.loc[grp.index,&#39;barcode_reference_dot_id&#39;] = brdi
                    #fish_counts.loc[grp.index,&#39;raw_barcodes&#39;] = barcode
                    #dists, index = nn_sklearn.kneighbors(all_barcodes, return_distance=True)

                all_decoded_dots_list.append(ref_selected_df_no_duplicates)

        if all_decoded_dots_list:
            all_decoded_dots_df = pd.concat(all_decoded_dots_list,ignore_index=False)
                    
                
            codebook_df = convert_str_codebook(codebook_df,&#39;Code&#39;)
            codebook_array = make_codebook_array(codebook_df,&#39;Code&#39;)
            nn_sklearn = NearestNeighbors(n_neighbors=1, metric=&#34;hamming&#34;)
            nn_sklearn.fit(codebook_array)

            all_barcodes = np.vstack(all_decoded_dots_df.raw_barcodes.map(lambda x: np.frombuffer(x, np.int8)).values)
            dists_arr, index_arr = nn_sklearn.kneighbors(all_barcodes, return_distance=True)
            genes=codebook_df.loc[index_arr.reshape(index_arr.shape[0]),&#39;Gene&#39;].tolist()

            all_decoded_dots_df.loc[:,&#39;decoded_genes&#39;] = genes
            all_decoded_dots_df.loc[:,&#39;hamming_distance&#39;] = dists_arr
            all_decoded_dots_df.loc[:,&#39;number_positive_bits&#39;] = all_barcodes.sum(axis=1)

            all_decoded_dots_df[&#39;barcodes_extraction_resolution&#39;] = barcodes_extraction_resolution
        else:
            all_decoded_dots_df = pd.DataFrame(columns = registered_counts_df.columns)
            all_decoded_dots_df[&#39;decoded_genes&#39;] = np.nan
            all_decoded_dots_df[&#39;hamming_distance&#39;] = np.nan
            all_decoded_dots_df[&#39;number_positive_bits&#39;] = np.nan
            all_decoded_dots_df[&#39;barcode_reference_dot_id&#39;] = np.nan
            all_decoded_dots_df[&#39;raw_barcodes&#39;] = np.nan
            all_decoded_dots_df[&#39;barcodes_extraction_resolution&#39;] = barcodes_extraction_resolution

        
        # Save barcoded_round and all_decoded_dots_df
        return barcoded_round, all_decoded_dots_df



# TODO Remove all the functions below
######## -------------------------------------------------------------------

class extract_barcodes_NN():
    &#34;&#34;&#34;
    Class used to extract the barcodes from the registered
    counts using nearest neighbour

    Parameters:
    -----------
    counts: pandas.DataFrame
        pandas file with the fov counts after
        registration
    analysis_parameters: dict
        parameters for data processing
    experiment_config: Dict
        dictionary with the experimental data 
    codebook_df: pandas.DataFrame
        pandas file with the codebook used to
        deconvolve the barcode

    NB: if there is a problem with the registration the barcode assigned 
        will be 0*barcode_length
    
    &#34;&#34;&#34;

    def __init__(self, counts, analysis_parameters:Dict,experiment_config:Dict,codebook_df,file_tags,status:str):
        
        self.barcodes_extraction_resolution = analysis_parameters[&#39;BarcodesExtractionResolution&#39;]
        self.RegistrationMinMatchingBeads = analysis_parameters[&#39;RegistrationMinMatchingBeads&#39;]
        self.barcode_length = experiment_config[&#39;Barcode_length&#39;]
        self.counts = counts
        self.logger = selected_logger()
        self.codebook_df = codebook_df
        self.file_tags = file_tags
        self.status = status
        self.registration_errors = Registration_errors()



        
    @staticmethod
    def barcode_nn(counts_df, ref_round_number, barcodes_extraction_resolution):
        column_names = list(counts_df.columns.values)
        column_names = column_names.append(&#39;barcode_reference_dot_id&#39;)
        barcoded_df = pd.DataFrame(columns=column_names)

        reference_array = counts_df.loc[counts_df.round_num == ref_round_number, [&#39;r_px_registered&#39;,&#39;c_px_registered&#39;]].to_numpy()
        reference_round_df = counts_df.loc[counts_df.round_num == ref_round_number,:].reset_index(drop=True)
        # Step one (all dots not in round 1)
        coords_compare = counts_df.loc[counts_df.round_num != ref_round_number, [&#39;r_px_registered&#39;,&#39;c_px_registered&#39;]].to_numpy()
        compare_df = counts_df.loc[counts_df.round_num != ref_round_number,:].reset_index(drop=True)

        if (reference_array.shape[0] &gt;0) and (coords_compare.shape[0] &gt;0):
            # initialize network
            nn = NearestNeighbors(n_neighbors=1, metric=&#34;euclidean&#34;)
            nn.fit(reference_array)

            # Get the nn
            dists, indices = nn.kneighbors(coords_compare, return_distance=True)

            # select only the nn that are below barcodes_extraction_resolution distance
            idx_selected_coords_compare = np.where(dists &lt;= barcodes_extraction_resolution)[0]

            compare_selected_df = compare_df.loc[idx_selected_coords_compare,:]
            compare_selected_df[&#39;barcode_reference_dot_id&#39;] = np.nan

            # ref_idx = indices[idx_selected_coords_compare]
            # compare_selected_df.loc[compare_selected_df.index.isin(idx_selected_coords_compare),&#39;barcode_reference_dot_id&#39;] = reference_round_df.loc[ref_idx,&#39;dot_id&#39;].values[0]
            
            for idx in idx_selected_coords_compare:
                ref_idx = indices[idx]
                compare_selected_df.loc[idx,&#39;barcode_reference_dot_id&#39;] = reference_round_df.loc[ref_idx,&#39;dot_id&#39;].values[0]

            reference_round_df[&#39;barcode_reference_dot_id&#39;] = reference_round_df.dot_id

            barcoded_df = barcoded_df.append([compare_selected_df, reference_round_df], ignore_index=True)

            compare_df = compare_df.drop(compare_selected_df.index)
            compare_df = compare_df.reset_index(drop=True)
    
        return compare_df, barcoded_df

    @staticmethod
    def convert_str_codebook(codebook_df,column_name):
        codebook_df[column_name] = codebook_df[column_name].map(lambda x: np.frombuffer(x, np.int8))
        return codebook_df

    @staticmethod
    def make_codebook_array(codebook_df,column_name):
        codebook_array = np.zeros((len(codebook_df[column_name]),codebook_df[column_name][0].shape[0]))
        for idx, el in enumerate(codebook_df[column_name]):
            row = codebook_df[column_name][idx]
            row = row[np.newaxis,:]
            codebook_array[idx,:] = row
        return codebook_array


    def run_extraction(self):

        data_models = Output_models()
        registration_errors = Registration_errors()
        fov = self.file_tags[&#39;fov&#39;]
        channel = self.file_tags[&#39;channel&#39;]
        self.barcoded_fov_df = data_models.barcode_analysis_df
        self.barcoded_fov_df.attrs = self.counts.attrs

        if self.status == &#39;FAILED&#39;:
            error = self.counts[&#39;min_number_matching_dots_registration&#39;].values[0]
            round_num = self.counts[&#39;round_num&#39;].values[0]
            self.barcoded_fov_df = self.barcoded_fov_df.append({&#39;min_number_matching_dots_registration&#39;:error,
                                                           &#39;fov_num&#39;:int(fov),&#39;dot_channel&#39;:channel,&#39;round_num&#39;: round_num },ignore_index=True)
        elif self.status == &#39;SUCCESS&#39;:

            if (min(self.counts.loc[:,&#39;min_number_matching_dots_registration&#39;]) &lt; self.RegistrationMinMatchingBeads):
                round_num = self.counts[&#39;round_num&#39;].values[0]
                self.barcoded_fov_df = self.barcoded_fov_df.append({&#39;min_number_matching_dots_registration&#39;:registration_errors.registration_below_extraction_resolution, 
                                            &#39;fov_num&#39;:int(fov),&#39;dot_channel&#39;:channel,&#39;round_num&#39;: round_num},ignore_index=True)
                self.status = &#39;FAILED&#39;
            else:
                hd_2 = 2 / self.barcode_length
                hd_3 = 3 / self.barcode_length
                # barcode_length = len(self.counts[&#39;round_num&#39;].unique())
                rounds = np.arange(1,self.barcode_length+1)
                self.codebook_df = self.convert_str_codebook(self.codebook_df,&#39;Code&#39;)
                codebook_array = self.make_codebook_array(self.codebook_df,&#39;Code&#39;)
                nn_sklearn = NearestNeighbors(n_neighbors=1, metric=&#34;hamming&#34;)
                nn_sklearn.fit(codebook_array)

                # remove points with np.NAN
                # self.counts = self.counts.dropna()
                for round_num in rounds:
                    compare_df, barcoded_df = self.barcode_nn(self.counts, round_num, self.barcodes_extraction_resolution)
                    self.barcoded_fov_df = self.barcoded_fov_df.append(barcoded_df, ignore_index=True)
                    self.counts = compare_df

                self.counts[&#39;barcode_reference_dot_id&#39;] = self.counts.dot_id
                self.barcoded_fov_df = self.barcoded_fov_df.append(self.counts, ignore_index=True)
                self.barcoded_fov_df[&#39;barcodes_extraction_resolution&#39;] = self.barcodes_extraction_resolution
                self.grpd = self.barcoded_fov_df.groupby(&#39;barcode_reference_dot_id&#39;)
                # self.all_barcodes = {}
                # for name, group in self.grpd:
                #     rounds_num = group.round_num.values
                #     dot_ids = group.dot_id.values
                #     rounds_num = rounds_num.astype(int)
                #     barcode = np.zeros([self.barcode_length],dtype=np.int8)
                #     barcode[(rounds_num-1)] += 1

                #     dists_arr, index_arr = nn_sklearn.kneighbors(barcode.reshape(1, -1), return_distance=True)
                #     gene=self.codebook_df.loc[index_arr.reshape(index_arr.shape[0]),&#39;Gene&#39;].tolist()[0]
                #     self.barcoded_fov_df.loc[self.barcoded_fov_df.barcode_reference_dot_id == name,&#39;raw_barcodes&#39;] = barcode.tostring()
                #     self.barcoded_fov_df.loc[self.barcoded_fov_df.barcode_reference_dot_id == name,&#39;all_Hdistance_genes&#39;] = gene
                #     if dists_arr[0][0] == 0:
                #         self.barcoded_fov_df.loc[self.barcoded_fov_df.barcode_reference_dot_id == name,&#39;0Hdistance_genes&#39;] = gene
                #     elif dists_arr[0][0] &lt; hd_2:
                #         self.barcoded_fov_df.loc[self.barcoded_fov_df.barcode_reference_dot_id == name,&#39;below2Hdistance_genes&#39;] = gene
                #     elif dists_arr[0][0] &lt; hd_3:
                #         self.barcoded_fov_df.loc[self.barcoded_fov_df.barcode_reference_dot_id == name,&#39;below3Hdistance_genes&#39;] = gene


                barcode_reference_dot_id_list = []
                num_unique_dots = np.unique(self.barcoded_fov_df.loc[:,&#39;barcode_reference_dot_id&#39;]).shape[0]
                
                # There are no dots is the df
                if num_unique_dots &gt; 0:
                
                    all_barcodes = np.zeros([num_unique_dots,self.barcode_length],dtype=np.int8)
                    for idx, (name, group) in enumerate(self.grpd):
                        barcode_reference_dot_id_list.append(name)
                        barcode = np.zeros([self.barcode_length],dtype=np.int8)
                        rounds_num = group.round_num.values
                        rounds_num = rounds_num.astype(int)
                        barcode[(rounds_num-1)] += 1
                        all_barcodes[idx,:] = barcode

                    dists_arr, index_arr = nn_sklearn.kneighbors(all_barcodes, return_distance=True)
                    genes=self.codebook_df.loc[index_arr.reshape(index_arr.shape[0]),&#39;Gene&#39;].tolist()
                    for idx,name in enumerate(barcode_reference_dot_id_list):
                        barcode = all_barcodes[idx,:]
                        gene = genes[idx]
                        hd = dists_arr[idx][0]

                        cols = [&#39;raw_barcodes&#39;,&#39;all_Hdistance_genes&#39;,&#39;number_positive_bits&#39;,&#39;hamming_distance&#39;] # will add last column depending on hd
                        writing_data = [barcode.tostring(),gene,barcode.sum(),hd]
                        if hd == 0:
                            cols = cols + [&#39;zeroHdistance_genes&#39;]
                            writing_data = writing_data + [gene]

                        if hd &lt; hd_2:
                            cols = cols + [&#39;below2Hdistance_genes&#39;]
                            writing_data = writing_data + [gene]

                        if hd &lt; hd_3:
                            cols = cols + [&#39;below3Hdistance_genes&#39;]
                            writing_data = writing_data + [gene]

                        self.barcoded_fov_df.loc[self.barcoded_fov_df.barcode_reference_dot_id == name,cols] = writing_data


                        # self.barcoded_fov_df.loc[self.barcoded_fov_df.barcode_reference_dot_id == name,&#39;raw_barcodes&#39;] = barcode.tostring()
                        # self.barcoded_fov_df.loc[self.barcoded_fov_df.barcode_reference_dot_id == name,&#39;all_Hdistance_genes&#39;] = gene
                        # self.barcoded_fov_df.loc[self.barcoded_fov_df.barcode_reference_dot_id == name,&#39;number_positive_bits&#39;] = barcode.sum()
                        # self.barcoded_fov_df.loc[self.barcoded_fov_df.barcode_reference_dot_id == name,&#39;hamming_distance&#39;] = hd

                        # if hd == 0:
                        #     self.barcoded_fov_df.loc[self.barcoded_fov_df.barcode_reference_dot_id == name,&#39;0Hdistance_genes&#39;] = gene
                        # elif hd &lt; hd_2:
                        #     self.barcoded_fov_df.loc[self.barcoded_fov_df.barcode_reference_dot_id == name,&#39;below2Hdistance_genes&#39;] = gene
                        # elif hd &lt; hd_3:
                        #     self.barcoded_fov_df.loc[self.barcoded_fov_df.barcode_reference_dot_id == name,&#39;below3Hdistance_genes&#39;] = gene
   
        fname = self.file_tags[&#39;experiment_fpath&#39;] / &#39;tmp&#39; / &#39;registered_counts&#39; / (self.file_tags[&#39;experiment_name&#39;] + &#39;_&#39; + self.file_tags[&#39;channel&#39;] + &#39;_decoded_fov_&#39; + self.file_tags[&#39;fov&#39;] + &#39;.parquet&#39;)
        self.barcoded_fov_df.to_parquet(fname,index=False)
   


class extract_barcodes_NN_test():
    &#34;&#34;&#34;
    Class used to extract the barcodes from the registered
    counts using nearest neighbour

    Parameters:
    -----------
    counts: pandas.DataFrame
        pandas file with the fov counts after
        registration
    analysis_parameters: dict
        parameters for data processing
    experiment_config: Dict
        dictionary with the experimental data 
    codebook_df: pandas.DataFrame
        pandas file with the codebook used to
        deconvolve the barcode

    NB: if there is a problem with the registration the barcode assigned 
        will be 0*barcode_length
    
    &#34;&#34;&#34;

    def __init__(self, fov, channel, counts, analysis_parameters:Dict,experiment_config:Dict,codebook_df,status:str):
        
        self.barcodes_extraction_resolution = analysis_parameters[&#39;BarcodesExtractionResolution&#39;]
        self.RegistrationMinMatchingBeads = analysis_parameters[&#39;RegistrationMinMatchingBeads&#39;]
        self.barcode_length = experiment_config[&#39;Barcode_length&#39;]
        self.fov = fov
        self.channel = channel
        self.counts = counts
        self.logger = selected_logger()
        self.codebook_df = codebook_df
        self.status = status
        self.registration_errors = Registration_errors()



        
    @staticmethod
    def barcode_nn(counts_df, ref_round_number, barcodes_extraction_resolution):
        column_names = list(counts_df.columns.values)
        column_names = column_names.append(&#39;barcode_reference_dot_id&#39;)
        barcoded_df = pd.DataFrame(columns=column_names)

        reference_array = counts_df.loc[counts_df.round_num == ref_round_number, [&#39;r_px_registered&#39;,&#39;c_px_registered&#39;]].to_numpy()
        reference_round_df = counts_df.loc[counts_df.round_num == ref_round_number,:].reset_index(drop=True)
        # Step one (all dots not in round 1)
        coords_compare = counts_df.loc[counts_df.round_num != ref_round_number, [&#39;r_px_registered&#39;,&#39;c_px_registered&#39;]].to_numpy()
        compare_df = counts_df.loc[counts_df.round_num != ref_round_number,:].reset_index(drop=True)

        if (reference_array.shape[0] &gt;0) and (coords_compare.shape[0] &gt;0):
            # initialize network
            nn = NearestNeighbors(n_neighbors=1, metric=&#34;euclidean&#34;)
            nn.fit(reference_array)

            # Get the nn
            dists, indices = nn.kneighbors(coords_compare, return_distance=True)

            # select only the nn that are below barcodes_extraction_resolution distance
            idx_selected_coords_compare = np.where(dists &lt;= barcodes_extraction_resolution)[0]

            compare_selected_df = compare_df.loc[idx_selected_coords_compare,:]
            compare_selected_df[&#39;barcode_reference_dot_id&#39;] = np.nan

            # ref_idx = indices[idx_selected_coords_compare]
            # compare_selected_df.loc[compare_selected_df.index.isin(idx_selected_coords_compare),&#39;barcode_reference_dot_id&#39;] = reference_round_df.loc[ref_idx,&#39;dot_id&#39;].values[0]
            
            for idx in idx_selected_coords_compare:
                ref_idx = indices[idx]
                compare_selected_df.loc[idx,&#39;barcode_reference_dot_id&#39;] = reference_round_df.loc[ref_idx,&#39;dot_id&#39;].values[0]

            reference_round_df[&#39;barcode_reference_dot_id&#39;] = reference_round_df.dot_id

            barcoded_df = barcoded_df.append([compare_selected_df, reference_round_df], ignore_index=True)

            compare_df = compare_df.drop(compare_selected_df.index)
            compare_df = compare_df.reset_index(drop=True)
    
        return compare_df, barcoded_df

    @staticmethod
    def convert_str_codebook(codebook_df,column_name):
        codebook_df[column_name] = codebook_df[column_name].map(lambda x: np.frombuffer(x, np.int8))
        return codebook_df

    @staticmethod
    def make_codebook_array(codebook_df,column_name):
        codebook_array = np.zeros((len(codebook_df[column_name]),codebook_df[column_name][0].shape[0]))
        for idx, el in enumerate(codebook_df[column_name]):
            row = codebook_df[column_name][idx]
            row = row[np.newaxis,:]
            codebook_array[idx,:] = row
        return codebook_array



    def run_extraction(self):

        data_models = Output_models()
        registration_errors = Registration_errors()
        self.barcoded_fov_df = data_models.barcode_analysis_df
        self.barcoded_fov_df.attrs = self.counts.attrs

        if self.status == &#39;FAILED&#39;:
            error = self.counts[&#39;min_number_matching_dots_registration&#39;].values[0]
            round_num = self.counts[&#39;round_num&#39;].values[0]
            self.barcoded_fov_df = self.barcoded_fov_df.append({&#39;min_number_matching_dots_registration&#39;:error,
                                                           &#39;fov_num&#39;:int(self.fov),&#39;dot_channel&#39;:self.channel,&#39;round_num&#39;: round_num },ignore_index=True)
        elif self.status == &#39;SUCCESS&#39;:

            if (min(self.counts.loc[:,&#39;min_number_matching_dots_registration&#39;]) &lt; self.RegistrationMinMatchingBeads):
                round_num = self.counts[&#39;round_num&#39;].values[0]
                self.barcoded_fov_df = self.barcoded_fov_df.append({&#39;min_number_matching_dots_registration&#39;:registration_errors.registration_below_extraction_resolution, 
                                            &#39;fov_num&#39;:int(self.fov),&#39;dot_channel&#39;:self.channel,&#39;round_num&#39;: round_num},ignore_index=True)
                self.status = &#39;FAILED&#39;
            else:
                hd_2 = 2 / self.barcode_length
                hd_3 = 3 / self.barcode_length
                # barcode_length = len(self.counts[&#39;round_num&#39;].unique())
                rounds = np.arange(1,self.barcode_length+1)
                self.codebook_df = self.convert_str_codebook(self.codebook_df,&#39;Code&#39;)
                codebook_array = self.make_codebook_array(self.codebook_df,&#39;Code&#39;)
                nn_sklearn = NearestNeighbors(n_neighbors=1, metric=&#34;hamming&#34;)
                nn_sklearn.fit(codebook_array)

                # remove points with np.NAN
                # self.counts = self.counts.dropna()
                for round_num in rounds:
                    compare_df, barcoded_df = self.barcode_nn(self.counts, round_num, self.barcodes_extraction_resolution)
                    self.barcoded_fov_df = self.barcoded_fov_df.append(barcoded_df, ignore_index=True)
                    self.counts = compare_df

                self.counts[&#39;barcode_reference_dot_id&#39;] = self.counts.dot_id
                self.barcoded_fov_df = self.barcoded_fov_df.append(self.counts, ignore_index=True)
                self.barcoded_fov_df[&#39;barcodes_extraction_resolution&#39;] = self.barcodes_extraction_resolution
                self.grpd = self.barcoded_fov_df.groupby(&#39;barcode_reference_dot_id&#39;)

                barcode_reference_dot_id_list = []
                num_unique_dots = np.unique(self.barcoded_fov_df.loc[:,&#39;barcode_reference_dot_id&#39;]).shape[0]
                
                # There are no dots is the df
                if num_unique_dots &gt; 0:
                
                    all_barcodes = np.zeros([num_unique_dots,self.barcode_length],dtype=np.int8)
                    for idx, (name, group) in enumerate(self.grpd):
                        barcode_reference_dot_id_list.append(name)
                        barcode = np.zeros([self.barcode_length],dtype=np.int8)
                        rounds_num = group.round_num.values
                        rounds_num = rounds_num.astype(int)
                        barcode[(rounds_num-1)] += 1
                        all_barcodes[idx,:] = barcode

                    dists_arr, index_arr = nn_sklearn.kneighbors(all_barcodes, return_distance=True)
                    genes=self.codebook_df.loc[index_arr.reshape(index_arr.shape[0]),&#39;Gene&#39;].tolist()
                    for idx,name in enumerate(barcode_reference_dot_id_list):
                        barcode = all_barcodes[idx,:]
                        gene = genes[idx]
                        hd = dists_arr[idx][0]

                        cols = [&#39;raw_barcodes&#39;,&#39;all_Hdistance_genes&#39;,&#39;number_positive_bits&#39;,&#39;hamming_distance&#39;] # will add last column depending on hd
                        writing_data = [barcode.tostring(),gene,barcode.sum(),hd]
                        if hd == 0:
                            cols = cols + [&#39;zeroHdistance_genes&#39;]
                            writing_data = writing_data + [gene]

                        if hd &lt; hd_2:
                            cols = cols + [&#39;below2Hdistance_genes&#39;]
                            writing_data = writing_data + [gene]

                        if hd &lt; hd_3:
                            cols = cols + [&#39;below3Hdistance_genes&#39;]
                            writing_data = writing_data + [gene]

                        self.barcoded_fov_df.loc[self.barcoded_fov_df.barcode_reference_dot_id == name,cols] = writing_data






class extract_barcodes_NN_new():
    &#34;&#34;&#34;
    Class used to extract the barcodes from the registered
    counts using nearest neighbour

    Parameters:
    -----------
    counts: pandas.DataFrame
        pandas file with the fov counts after
        registration
    analysis_parameters: dict
        parameters for data processing
    experiment_config: Dict
        dictionary with the experimental data 
    codebook_df: pandas.DataFrame
        pandas file with the codebook used to
        deconvolve the barcode

    NB: if there is a problem with the registration the barcode assigned 
        will be 0*barcode_length
    
    &#34;&#34;&#34;

    def __init__(self, registered_counts, analysis_parameters:Dict,experiment_config:Dict,codebook_df):
        
        self.counts_df = registered_counts
        self.analysis_parameters = analysis_parameters
        self.experiment_config = experiment_config
        self.codebook_df = codebook_df
        
        self.logger = selected_logger()
        
        self.barcodes_extraction_resolution = analysis_parameters[&#39;BarcodesExtractionResolution&#39;]
        self.RegistrationMinMatchingBeads = analysis_parameters[&#39;RegistrationMinMatchingBeads&#39;]
        self.barcode_length = self.counts_df.loc[0][&#39;barcode_length&#39;]
        self.registration_errors = Registration_errors()

        self.stitching_channel = self.counts_df[&#39;stitching_channel&#39;].iloc[0]
        
    @staticmethod
    def convert_str_codebook(codebook_df,column_name):
        codebook_df[column_name] = codebook_df[column_name].map(lambda x: np.frombuffer(x, np.int8))
        return codebook_df

    @staticmethod
    def make_codebook_array(codebook_df,column_name):
        codebook_array = np.zeros((len(codebook_df[column_name]),codebook_df[column_name][0].shape[0]))
        for idx, el in enumerate(codebook_df[column_name]):
            row = codebook_df[column_name][idx]
            row = row[np.newaxis,:]
            codebook_array[idx,:] = row
        return codebook_array

    
    @staticmethod
    def barcode_nn(counts_df, ref_round_number, barcodes_extraction_resolution):
        column_names = list(counts_df.columns.values)
        column_names = column_names.append(&#39;barcode_reference_dot_id&#39;)
        barcoded_df = pd.DataFrame(columns=column_names)

        
        reference_array = counts_df.loc[counts_df.round_num == ref_round_number, [&#39;r_px_registered&#39;,&#39;c_px_registered&#39;]].to_numpy()
        reference_round_df = counts_df.loc[counts_df.round_num == ref_round_number,:].reset_index(drop=True)
    
        # Step one (all dots not in round 1)
        coords_compare = counts_df.loc[counts_df.round_num != ref_round_number, [&#39;r_px_registered&#39;,&#39;c_px_registered&#39;]].to_numpy()
        compare_df = counts_df.loc[counts_df.round_num != ref_round_number,:].reset_index(drop=True)
        
        if (reference_array.shape[0] &gt;0) and (coords_compare.shape[0] &gt;0):
            # initialize network
            nn = NearestNeighbors(n_neighbors=1, metric=&#34;euclidean&#34;)
            nn.fit(reference_array)

            # Get the nn
            dists, indices = nn.kneighbors(coords_compare, return_distance=True)

            # select only the nn that are below barcodes_extraction_resolution distance
            idx_selected_coords_compare = np.where(dists &lt;= barcodes_extraction_resolution)[0]
            compare_selected_df = compare_df.loc[idx_selected_coords_compare,:]
            compare_selected_df[&#39;barcode_reference_dot_id&#39;] = np.nan
            
            for k,v in groupby(idx_selected_coords_compare):
                if len(list(v)) &gt; 3:
                    print(&#34;key: &#39;{}&#39;--&gt; group: {}&#34;.format(k, len(list(v))))
            # ref_idx = indices[idx_selected_coords_compare].squeeze()
            # compare_selected_df.loc[compare_selected_df.index.isin(idx_selected_coords_compare),&#39;barcode_reference_dot_id&#39;] = reference_round_df.loc[ref_idx,&#39;dot_id&#39;].values[0]

            for idx in idx_selected_coords_compare:
                ref_idx = indices[idx]
                compare_selected_df.loc[idx,&#39;barcode_reference_dot_id&#39;] = reference_round_df.loc[ref_idx,&#39;dot_id&#39;].values[0]

            reference_round_df[&#39;barcode_reference_dot_id&#39;] = reference_round_df.dot_id

            barcoded_df = barcoded_df.append([compare_selected_df, reference_round_df], ignore_index=True)

            compare_df = compare_df.drop(compare_selected_df.index)
            compare_df = compare_df.reset_index(drop=True)
            
        return compare_df, barcoded_df

        
    def run_extraction(self):

        data_models = Output_models()
        registration_errors = Registration_errors()
        self.barcoded_spec = data_models.barcode_analysis_df

        if not self.counts_df[self.counts_df[&#39;dot_id&#39;].isnull()].empty:
            print(&#39;shitty FOV&#39;)
            self.all_combine_df = pd.concat([self.counts_df,self.barcoded_spec],axis=1)

        elif (min(self.counts_df[&#39;min_number_matching_dots_registration&#39;]) &lt; self.RegistrationMinMatchingBeads):

            self.counts_df[&#39;min_number_matching_dots_registration&#39;] = registration_errors.registration_below_extraction_resolution
            self.all_combine_df = pd.concat([self.counts_df,self.barcoded_spec],axis=1)

        else:
            self.counts_df = pd.concat([self.counts_df,self.barcoded_spec],axis=1)
            self.fish_counts = self.counts_df.loc[self.counts_df.channel != self.stitching_channel,:]
            
            hd_2 = 2 / self.barcode_length
            hd_3 = 3 / self.barcode_length
            rounds = np.arange(1,self.barcode_length+1)
            self.codebook_df = self.convert_str_codebook(self.codebook_df,&#39;Code&#39;)
            codebook_array = self.make_codebook_array(self.codebook_df,&#39;Code&#39;)
            nn_sklearn = NearestNeighbors(n_neighbors=1, metric=&#34;hamming&#34;)
            nn_sklearn.fit(codebook_array)
            
    
            self.index_df = pd.DataFrame(index=self.fish_counts.index,
                                        columns = [&#39;barcode_reference_dot_id&#39;,&#39;raw_barcodes&#39;])
            
            barcoded_df_list = []
            self.barcoded_fov_df = pd.DataFrame()
            for round_num in rounds:
                compare_df, barcoded_df = self.barcode_nn(self.fish_counts, round_num, self.barcodes_extraction_resolution)
                barcoded_df_list.append(barcoded_df)
                self.fish_counts = compare_df
            self.barcoded_fov_df = pd.concat(barcoded_df_list, ignore_index=True)
                
            self.fish_counts[&#39;barcode_reference_dot_id&#39;] = self.fish_counts.dot_id
            self.barcoded_fov_df = self.barcoded_fov_df.append(self.fish_counts, ignore_index=True)
            self.barcoded_fov_df[&#39;barcodes_extraction_resolution&#39;] = self.barcodes_extraction_resolution        
            self.grpd = self.barcoded_fov_df.groupby(&#39;barcode_reference_dot_id&#39;)

            barcode_reference_dot_id_list = []
            num_unique_dots = np.unique(self.barcoded_fov_df.loc[:,&#39;barcode_reference_dot_id&#39;]).shape[0]

            # There are no dots is the df
            if num_unique_dots &gt; 0:

                all_barcodes = np.zeros([num_unique_dots,self.barcode_length],dtype=np.int8)
                for idx, (name, group) in enumerate(self.grpd):
                    barcode_reference_dot_id_list.append(name)
                    barcode = np.zeros([self.barcode_length],dtype=np.int8)
                    rounds_num = group.round_num.values
                    rounds_num = rounds_num.astype(int)
                    barcode[(rounds_num-1)] += 1
                    all_barcodes[idx,:] = barcode

                dists_arr, index_arr = nn_sklearn.kneighbors(all_barcodes, return_distance=True)
                genes=self.codebook_df.loc[index_arr.reshape(index_arr.shape[0]),&#39;Gene&#39;].tolist()
                
                self.all_combine_df_list = []
                self.all_combine_df = pd.DataFrame()
                
                for idx, (name, group) in enumerate(self.grpd):
                    barcode = all_barcodes[idx,:]
                    gene = genes[idx]
                    hd = dists_arr[idx][0]

                    group_df = group
                    
                    group_df[&#39;raw_barcodes&#39;] = barcode.tostring()
                    group_df[&#39;all_Hdistance_genes&#39;] = gene
                    group_df[&#39;number_positive_bits&#39;] = barcode.sum()
                    group_df[&#39;hamming_distance&#39;] = hd
                    group_df[&#39;zeroHdistance_genes&#39;] = np.nan
                    group_df[&#39;below2Hdistance_genes&#39;] = np.nan
                    group_df[&#39;below3Hdistance_genes&#39;] = np.nan
                    
                    if hd == 0:
                        group_df[&#39;zeroHdistance_genes&#39;] = gene
                    if hd &lt; hd_2:
                        group_df[&#39;below2Hdistance_genes&#39;] = gene
                    if hd &lt; hd_3:
                        group_df[&#39;below3Hdistance_genes&#39;] = gene
                    
                    self.all_combine_df_list.append(group_df)
                
                # self.all_combine_df = pd.concat(self.all_combine_df_list, axis=0,copy=False) 
                chunk_size = 500
                self.all_combine_df = merge_with_concat((merge_with_concat(dfs) for dfs in chunk_dfs(self.all_combine_df_list, chunk_size)))
  
            else:
                self.all_combine_df = self.fish_counts   # add the missing column and control error for stitching


def decoder_fun(registered_counts, analysis_parameters,experiment_info,codebook_df):
    dc = extract_barcodes_NN_new(registered_counts, analysis_parameters,experiment_info,codebook_df)
    dc.run_extraction()
    return dc.all_combine_df


def convert_str_codebook(codebook_df,column_name):
    codebook_df[column_name] = codebook_df[column_name].map(lambda x: np.frombuffer(x, np.int8))
    return codebook_df

def make_codebook_array(codebook_df,column_name):
    codebook_array = np.zeros((len(codebook_df[column_name]),codebook_df[column_name][0].shape[0]))
    for idx, el in enumerate(codebook_df[column_name]):
        row = codebook_df[column_name][idx]
        row = row[np.newaxis,:]
        codebook_array[idx,:] = row
    return codebook_array






#                 chunk_size = 100
#                 self.all_combine_df = merge_with_concat((merge_with_concat(dfs) for dfs in chunk_dfs(self.all_combine_df_list, chunk_size)))
                

def extract_barcodes_NN_fast(registered_counts_df, analysis_parameters:Dict,codebook_df):
    &#34;&#34;&#34;
    Class used to extract the barcodes from the registered
    counts using nearest neighbour

    Parameters:
    -----------
    counts: pandas.DataFrame
        pandas file with the fov counts after
        registration
    analysis_parameters: dict
        parameters for data processing 
    codebook_df: pandas.DataFrame
        pandas file with the codebook used to
        deconvolve the barcode

    NB: if there is a problem with the registration the barcode assigned 
        will be 0*barcode_length
    
    &#34;&#34;&#34;

    logger = selected_logger()

    barcodes_extraction_resolution = analysis_parameters[&#39;BarcodesExtractionResolution&#39;]
    RegistrationMinMatchingBeads = analysis_parameters[&#39;RegistrationMinMatchingBeads&#39;]
    barcode_length = registered_counts_df.loc[0][&#39;barcode_length&#39;]
    registration_errors = Registration_errors()

    stitching_channel = registered_counts_df[&#39;stitching_channel&#39;].iloc[0]
    
    fish_counts = registered_counts_df.loc[registered_counts_df.channel != stitching_channel,:]
    stitching_channel_counts = registered_counts_df.loc[registered_counts_df.channel == stitching_channel,:]
    
    fish_counts.dropna(subset=[&#39;dot_id&#39;],inplace=True)
    # Starting level for selection of dots
    dropping_counts = fish_counts.copy(deep=True)

    all_decoded_dots_list = []

    if fish_counts[&#39;r_px_registered&#39;].isnull().values.any():
        
        all_decoded_dots_df = pd.DataFrame(columns = fish_counts.columns)
        all_decoded_dots_df[&#39;decoded_genes&#39;] = np.nan
        all_decoded_dots_df[&#39;hamming_distance&#39;] = np.nan
        all_decoded_dots_df[&#39;number_positive_bits&#39;] = np.nan
        all_decoded_dots_df[&#39;barcode_reference_dot_id&#39;] = np.nan
        all_decoded_dots_df[&#39;raw_barcodes&#39;] = np.nan
        all_decoded_dots_df[&#39;barcodes_extraction_resolution&#39;] = barcodes_extraction_resolution
        # Save barcoded_round and all_decoded_dots_df
        return fish_counts, all_decoded_dots_df
        
    else:
    
        for ref_round_number in np.arange(1,barcode_length+1):

            #ref_round_number = 1
            reference_round_df = dropping_counts.loc[dropping_counts.round_num == ref_round_number,:]
            # Step one (all dots not in round 1)
            compare_df = dropping_counts.loc[dropping_counts.round_num != ref_round_number,:]

            if (not reference_round_df.empty) and (not compare_df.empty):
                nn = NearestNeighbors(n_neighbors=1, metric=&#34;euclidean&#34;)
                nn.fit(reference_round_df[[&#39;r_px_registered&#39;,&#39;c_px_registered&#39;]])
                dists, indices = nn.kneighbors(compare_df[[&#39;r_px_registered&#39;,&#39;c_px_registered&#39;]], return_distance=True)

                # select only the nn that are below barcodes_extraction_resolution distance
                idx_distances_below_resolution = np.where(dists &lt;= barcodes_extraction_resolution)[0]

                comp_idx = idx_distances_below_resolution
                ref_idx = indices[comp_idx].flatten()

                # Subset the dataframe according to the selected points
                # The reference selected will have repeated points
                comp_selected_df = compare_df.iloc[comp_idx]
                ref_selected_df = reference_round_df.iloc[ref_idx]

               # The size of ref_selected_df w/o duplicates may be smaller of reference_round_df if 
                # some of the dots in reference_round_df have no neighbours

                # Test approach where we get rid of the single dots
                comp_selected_df.loc[:,&#39;barcode_reference_dot_id&#39;] = ref_selected_df[&#39;dot_id&#39;].values
                ref_selected_df_no_duplicates = ref_selected_df.drop_duplicates()
                ref_selected_df_no_duplicates.loc[:,&#39;barcode_reference_dot_id&#39;] = ref_selected_df_no_duplicates[&#39;dot_id&#39;].values

                barcoded_round = pd.concat([comp_selected_df, ref_selected_df_no_duplicates], axis=0,ignore_index=False)
                barcoded_round_grouped = barcoded_round.groupby(&#39;barcode_reference_dot_id&#39;)
                for brdi, grp in barcoded_round_grouped:
                    barcode = np.zeros([barcode_length],dtype=np.int8)
                    barcode[grp.round_num.values.astype(np.int8)-1] = 1
                    #hamming_dist, index_gene = nn_sklearn.kneighbors(barcode.reshape(1, -1), return_distance=True)
                    #gene= codebook_df.loc[index_gene.reshape(index_gene.shape[0]),&#39;Gene&#39;].tolist()

                    barcode = barcode.tostring()
                    ref_selected_df_no_duplicates.loc[ref_selected_df_no_duplicates.barcode_reference_dot_id == brdi,&#39;raw_barcodes&#39;] = barcode
                    #ref_selected_df_no_duplicates.loc[ref_selected_df_no_duplicates.barcode_reference_dot_id == brdi,&#39;decoded_gene_name&#39;] = gene
                    #ref_selected_df_no_duplicates.loc[ref_selected_df_no_duplicates.barcode_reference_dot_id == brdi,&#39;hamming_distance&#39;] = hamming_dist.flatten()[0]

                    #fish_counts.loc[grp.index,&#39;barcode_reference_dot_id&#39;] = brdi
                    #fish_counts.loc[grp.index,&#39;raw_barcodes&#39;] = barcode
                    #dists, index = nn_sklearn.kneighbors(all_barcodes, return_distance=True)

                all_decoded_dots_list.append(ref_selected_df_no_duplicates)

                all_decoded_dots_df = pd.concat(all_decoded_dots_list,ignore_index=False)
                
                compare_df = compare_df.drop(comp_selected_df.index)
                dropping_counts = compare_df

        codebook_df = convert_str_codebook(codebook_df,&#39;Code&#39;)
        codebook_array = make_codebook_array(codebook_df,&#39;Code&#39;)
        nn_sklearn = NearestNeighbors(n_neighbors=1, metric=&#34;hamming&#34;)
        nn_sklearn.fit(codebook_array)

        all_barcodes = np.vstack(all_decoded_dots_df.raw_barcodes.map(lambda x: np.frombuffer(x, np.int8)).values)
        dists_arr, index_arr = nn_sklearn.kneighbors(all_barcodes, return_distance=True)
        genes=codebook_df.loc[index_arr.reshape(index_arr.shape[0]),&#39;Gene&#39;].tolist()

        all_decoded_dots_df.loc[:,&#39;decoded_genes&#39;] = genes
        all_decoded_dots_df.loc[:,&#39;hamming_distance&#39;] = dists_arr
        all_decoded_dots_df.loc[:,&#39;number_positive_bits&#39;] = all_barcodes.sum(axis=1)

        all_decoded_dots_df = pd.concat([all_decoded_dots_df,stitching_channel_counts])
        all_decoded_dots_df[&#39;barcodes_extraction_resolution&#39;] = barcodes_extraction_resolution

        # Save barcoded_round and all_decoded_dots_df
        return barcoded_round, all_decoded_dots_df



#                 chunk_size = 100
#                 self.all_combine_df = merge_with_concat((merge_with_concat(dfs) for dfs in chunk_dfs(self.all_combine_df_list, chunk_size)))
                




   # ---------------------------------------------------




class extract_barcodes():
    &#34;&#34;&#34;
    Class used to extract the barcodes from the registered
    counts

    Parameters:
    -----------
    counts: pandas dataframe
        contains all the counts for a fov
    pxl: int
        size of the hood to search for positive
        barcodes
    &#34;&#34;&#34;

    def __init__(self, counts, pxl:int,save=True):
        self.counts = counts
        self.pxl = pxl
        self.save = save

        self.logger = logging.getLogger(__name__)

    @staticmethod
    def combine_coords(counts, round_num, counts_type=&#39;registered&#39;):
        data_reference = counts.loc[counts[&#39;round_num&#39;] == round_num]
        if counts_type == &#39;registered&#39;:
            r_px = data_reference.r_px_registered.to_list()
            c_px = data_reference.c_px_registered.to_list()
        elif counts_type == &#39;original&#39;:
            r_px = data_reference.r_px_original.to_list()
            c_px = data_reference.c_px_original.to_list()
        coords = np.array(list(zip(r_px,c_px)))
        position_idx = data_reference.index
        return coords, position_idx
    
    @staticmethod
    def dots_hoods(coords,pxl):
        r_tl = coords[:,0]-pxl
        r_br = coords[:,0]+pxl
        c_tl = coords[:,1]-pxl
        c_tr = coords[:,1]+pxl
        r_tl = r_tl[:,np.newaxis]
        r_br = r_br[:,np.newaxis]
        c_tl = c_tl[:,np.newaxis]
        c_tr = c_tr[:,np.newaxis]
        chunks_coords = np.hstack((r_tl,r_br,c_tl,c_tr))
        chunks_coords = chunks_coords.astype(int)
        return chunks_coords

    @staticmethod
    def barcode_detection(all_coords_image,chunk_coords,pxl):
        selected_region = all_coords_image[:,chunk_coords[0]:chunk_coords[1]+1,chunk_coords[2]:chunk_coords[3]+1]
        barcode = np.sum(selected_region, axis=(1,2))
        return barcode, selected_region

    def run_extraction(self):
        # add check to make sure that the counts are there
        column_names = [&#39;r_px_original&#39;,&#39;c_px_original&#39;,&#39;dot_id&#39;,&#39;fov_num&#39;,&#39;round_num&#39;,&#39;dot_intensity_norm&#39;,
                        &#39;dot_intensity_not&#39;,&#39;selected_thr&#39; ,&#39;channel&#39;,&#39;r_shift&#39;,&#39;c_shift&#39;,&#39;r_px_registered&#39;,
                        &#39;c_px_registered&#39;,&#39;pixel_microns&#39;]
        column_names_output = column_names.copy()
        column_names_output.append(&#39;pxl_hood_size&#39;)
        column_names_output.append(&#39;raw_barcodes&#39;)
        self.barcodes_binary_images = {}
        if len(self.counts[&#39;r_px_registered&#39;]) &gt; 1:
            r_num = int(self.counts[&#39;r_px_registered&#39;].max())
            c_num = int(self.counts[&#39;c_px_registered&#39;].max())
            rounds_num = len(self.counts[&#39;round_num&#39;].unique())
            all_coords_image = np.zeros([rounds_num,r_num+1,c_num+1],dtype=np.int8)
            for round_num in np.arange(1,rounds_num+1):
                coords, ref_position_idx = self.combine_coords(self.counts, round_num, counts_type=&#39;registered&#39;)
                if np.any(np.isnan(coords)):
                    stop = True
                    break
                else:
                    stop = False
                    coords = coords.astype(np.int)
                    all_coords_image[round_num-1,coords[:,0],coords[:,1]] = 1

            if stop:
                self.logger.error(f&#39;missing round {coords} no barcodes&#39;)
                self.output = pd.DataFrame(np.nan,index=[0],columns = column_names_output)
            else:
                self.output = pd.DataFrame(columns = column_names_output)
                self.output[&#39;pxl_hood_size&#39;] = np.nan
                self.output[&#39;raw_barcodes&#39;] = np.nan
                # self.raw_barcodes = []
                for round_num in np.arange(1,rounds_num+1):
                    coords, ref_position_idx = self.combine_coords(self.counts, round_num, counts_type=&#39;registered&#39;)
                    dot_ids = self.counts.loc[ref_position_idx,&#39;dot_id&#39;]
                    dot_ids = dot_ids.reset_index()
                    chunks_coords = self.dots_hoods(coords,self.pxl)
                    for row in np.arange(coords.shape[0]):
                        chunk = chunks_coords[row,:]
                        dot_id = dot_ids.loc[row,&#39;dot_id&#39;]
                        selected_dot_coords = coords[row,:].astype(int)
                        barcode,selected_region = self.barcode_detection(all_coords_image,chunk,self.pxl)
                        # Add only the barcodes that are not all negatives (can happen because I am blanking the img)
                        if barcode.sum():
                            self.barcodes_binary_images[dot_id] = {}
                            self.barcodes_binary_images[dot_id][&#39;img&#39;] = selected_region
                            self.barcodes_binary_images[dot_id][&#39;raw_barcode&#39;] = barcode
                            # self.raw_barcodes.append(barcode)
                            # Blank the image
                            all_coords_image[:,selected_dot_coords[0],selected_dot_coords[1]] = 0
                            dot_data = self.counts[(self.counts[&#39;round_num&#39;] == round_num) &amp; (self.counts[&#39;r_px_registered&#39;] == selected_dot_coords[0]) &amp; (self.counts[&#39;c_px_registered&#39;] == selected_dot_coords[1])] 
                            barcode_st = &#39;&#39;
                            barcode_st = barcode_st.join([&#34;,&#34;.join(item) for item in barcode.astype(str)])
                            dot_data.insert(0,&#39;raw_barcodes&#39;,barcode_st)
                            dot_data.insert(0,&#39;pxl_hood_size&#39;,self.pxl)
                            self.output = pd.concat([self.output,dot_data],axis=0,ignore_index=True)
        
                # self.output[&#39;pxl_hood_size&#39;] = self.pxl
                # self.output[&#39;raw_barcodes&#39;] = self.raw_barcodes
        else:
            if self.save:
                self.output = pd.DataFrame(np.nan,index=[0],columns = column_names_output)





# class extract_barcodes_NN_descend():
#     &#34;&#34;&#34;
#     Class used to extract the barcodes from the registered
#     counts using nearest neighbour

#     Parameters:
#     -----------
#     counts: pandas dataframe
#         contains all the counts for a fov
#     pxl: int
#         size of the hood to search for positive
#         barcodes

#     NB: If a round is missing everything get processed
#         but the missing rounds get 0 in the barcode
#     &#34;&#34;&#34;

#     def __init__(self, counts, pxl:int,total_rounds:int):
#         self.counts = counts
#         self.pxl = pxl
#         self.total_rounds = total_rounds

#         #self.logger = logging.getLogger(__name__)

        
#     @staticmethod
#     def barcode_nn(counts_df, ref_round_number, pxl):
#         column_names = list(counts_df.columns.values)
#         column_names = column_names.append(&#39;barcode_reference_dot_id&#39;)
#         barcoded_df = pd.DataFrame(columns=column_names)

#         reference_array = counts_df.loc[counts_df.round_num == ref_round_number, [&#39;r_px_registered&#39;,&#39;c_px_registered&#39;]].to_numpy()
#         reference_round_df = counts_df.loc[counts_df.round_num == ref_round_number,:].reset_index(drop=True)
#         # Step one (all dots not in round 1)
#         coords_compare = counts_df.loc[counts_df.round_num != ref_round_number, [&#39;r_px_registered&#39;,&#39;c_px_registered&#39;]].to_numpy()
#         compare_df = counts_df.loc[counts_df.round_num != ref_round_number,:].reset_index(drop=True)

#         if (reference_array.shape[0] &gt;0) and (coords_compare.shape[0] &gt;0):
#             # initialize network
    
#             index = NNDescent(reference_array,metric=&#39;euclidean&#39;,n_neighbors=1)        
#             # Get the nn
#             indices, dists = index.query(coords_compare,k=1)
#             # select only the nn that are below pxl distance
#             idx_selected_coords_compare = np.where(dists &lt;= pxl)[0]

#             compare_selected_df = compare_df.loc[idx_selected_coords_compare,:]
#             compare_selected_df[&#39;barcode_reference_dot_id&#39;] = np.nan

#             for idx in idx_selected_coords_compare:
#                 ref_idx = indices[idx]
#                 compare_selected_df.loc[idx,&#39;barcode_reference_dot_id&#39;] = reference_round_df.loc[ref_idx,&#39;dot_id&#39;].values[0]

#             reference_round_df[&#39;barcode_reference_dot_id&#39;] = reference_round_df.dot_id

#             barcoded_df = barcoded_df.append([compare_selected_df, reference_round_df], ignore_index=True)

#             compare_df = compare_df.drop(compare_selected_df.index)
#             compare_df = compare_df.reset_index(drop=True)
    
#         return compare_df, barcoded_df


#     def run_extraction(self):

#         # count all barcodes
#         columns_names = [&#39;r_px_original&#39;, &#39;c_px_original&#39;, &#39;dot_id&#39;, &#39;fov_num&#39;,
#         &#39;round_num&#39;, &#39;dot_intensity_norm&#39;, &#39;dot_intensity_not&#39;,
#         &#39;selected_thr&#39;, &#39;channel&#39;, &#39;r_shift&#39;, &#39;c_shift&#39;, &#39;r_px_registered&#39;,
#         &#39;c_px_registered&#39;, &#39;pixel_microns&#39;, &#39;pxl_hood_size&#39;, &#39;barcode_reference_dot_id&#39;]

#         self.barcoded_fov_df = pd.DataFrame(columns=columns_names)
        
#         rounds = np.arange(1,self.total_rounds+1)
        
#          # Check that counts not NaN
#         if not self.counts[&#39;r_px_original&#39;].isnull().all():

#             # remove points with np.NAN
#             self.counts = self.counts.dropna()
#             for round_num in np.arange(1,self.total_rounds):
#                 compare_df, barcoded_df = self.barcode_nn(self.counts, round_num, self.pxl)
#                 self.barcoded_fov_df = self.barcoded_fov_df.append(barcoded_df, ignore_index=True)
#                 self.counts = compare_df

#             self.counts[&#39;barcode_reference_dot_id&#39;] = self.counts.dot_id
#             self.barcoded_fov_df = self.barcoded_fov_df.append(self.counts, ignore_index=True)
#             self.barcoded_fov_df[&#39;pxl_hood_size&#39;] = self.pxl
#             self.grpd = self.barcoded_fov_df.groupby(&#39;barcode_reference_dot_id&#39;)
#             self.all_barcodes = {}
#             for name, group in self.grpd:
#                 rounds_num = group.round_num.values
#                 dot_ids = group.dot_id.values
#                 rounds_num = rounds_num.astype(int)
#                 barcode = np.zeros([1,self.total_rounds],dtype=int)
#                 barcode[:,(rounds_num-1)] += 1
#                 barcode_st = &#39;&#39;
#                 barcode_st = barcode_st.join([&#34;,&#34;.join(item) for item in barcode.astype(str)])
#                 self.all_barcodes[name] = {}
#                 self.all_barcodes[name][&#39;dot_ids&#39;] = dot_ids
#                 self.all_barcodes[name][&#39;barcode&#39;] = barcode
#                 self.all_barcodes[name][&#39;barcode_str&#39;] = barcode_st
#         else:
#             self.all_barcodes[name] = {}


# def convert_str_codebook(codebook_df,column_name):
#     codebook_df[column_name] = codebook_df[column_name].map(lambda x: np.frombuffer(x, np.int8))
#     return codebook_df


# def make_codebook_array(codebook_df,column_name):
#     codebook_array = np.zeros((len(codebook_df[column_name]),codebook_df[column_name][0].shape[0]))
#     for idx, el in enumerate(codebook_df[column_name]):
#         row = codebook_df[column_name][idx]
#         row = row[np.newaxis,:]
#         codebook_array[idx,:] = row
#     return codebook_array

# def nn_decoding_barcodes(counts_df, codebook_df):

#     if counts_df.empty:
#         counts_df[&#39;gene&#39;] = np.nan
#         counts_df[&#39;hamming_distance_barcode&#39;] = np.nan
#     else:
#         codebook_barcode_array_df = convert_str_codebook(codebook_df,&#39;Code&#39;)
#         codebook_array = make_codebook_array(codebook_df,&#39;Code&#39;)
#         nn_sklearn = NearestNeighbors(n_neighbors=1, metric=&#34;hamming&#34;)
#         nn_sklearn.fit(codebook_array)

#         grpd_counts = counts_df.groupby(&#39;barcode_reference_dot_id&#39;)

#         barcodes_dots_ids = list(grpd_counts.groups.keys())
#         subgroup_counts = counts_df.loc[counts_df.dot_id.isin(barcodes_dots_ids),:].copy()
#         subgroup_counts = subgroup_counts.reset_index()

#         subgroup_counts_array_df = convert_str_codebook(subgroup_counts,&#39;raw_barcodes&#39;)
#         subgroup_counts_array = make_codebook_array(subgroup_counts_array_df,&#39;raw_barcodes&#39;)

#         dists_arr, index_arr = nn_sklearn.kneighbors(subgroup_counts_array, return_distance=True)

#         all_genes=codebook_df.loc[index_arr.reshape(index_arr.shape[0]),&#39;Gene&#39;].tolist()

#         subgroup_counts_array_df[&#39;hamming_distance_barcode&#39;] = dists_arr
#         subgroup_counts_array_df[&#39;gene&#39;] = all_genes

#         counts_df[&#39;gene&#39;] = np.nan
#         counts_df[&#39;hamming_distance_barcode&#39;] = np.nan
#         for ref in subgroup_counts_array_df.dot_id.values:  
#             counts_df.loc[counts_df.barcode_reference_dot_id == ref, [&#39;gene&#39;]] = subgroup_counts_array_df.loc[subgroup_counts_array_df.dot_id == ref, [&#39;gene&#39;]].values[0][0]
#             counts_df.loc[counts_df.barcode_reference_dot_id == ref, [&#39;hamming_distance_barcode&#39;]] = subgroup_counts_array_df.loc[subgroup_counts_array_df.dot_id == ref, [&#39;hamming_distance_barcode&#39;]].values[0][0]        

#     return counts_df




# if __name__ == &#39;__main__&#39;:
#     import pandas as pd
#     import pickle
#     counts = pd.read_csv(&#39;/Users/simone/Documents/local_data_storage/LBEXP20200325_oPool11/counts/roi_0/Cy5/LBEXP20200325_oPool11_roi_0_Cy5_fov_90.csv&#39;)
#     pxl = 0.5
#     total_rounds = 16
#     bc = extract_barcodes_NN(counts,pxl,total_rounds)
#     bc.run_extraction()
#     pickle.dump(bc.barcodes_binary_images,open(&#39;/Users/simone/Downloads/binary_images.pkl&#39;,&#39;wb&#39;))
#     print(f&#39;cane&#39;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pysmFISH.barcodes_analysis.chunk_dfs"><code class="name flex">
<span>def <span class="ident">chunk_dfs</span></span>(<span>dataframes_list: list, chunk_size: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Functions modified from
<a href="https://stackoverflow.com/questions/45217120/how-to-efficiently-join-merge-concatenate-large-data-frame-in-pandas">https://stackoverflow.com/questions/45217120/how-to-efficiently-join-merge-concatenate-large-data-frame-in-pandas</a>
yields n dataframes at a time where n == chunksize</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def chunk_dfs(dataframes_list: list, chunk_size: int):
    &#34;&#34;&#34; 
    Functions modified from
    https://stackoverflow.com/questions/45217120/how-to-efficiently-join-merge-concatenate-large-data-frame-in-pandas
    yields n dataframes at a time where n == chunksize 
    &#34;&#34;&#34;
    dfs = []
    for f in dataframes_list:
        dfs.append(f)
        if len(dfs) == chunk_size:
            yield dfs
            dfs  = []
    if dfs:
        yield dfs</code></pre>
</details>
</dd>
<dt id="pysmFISH.barcodes_analysis.convert_str_codebook"><code class="name flex">
<span>def <span class="ident">convert_str_codebook</span></span>(<span>codebook_df, column_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_str_codebook(codebook_df,column_name):
    codebook_df[column_name] = codebook_df[column_name].map(lambda x: np.frombuffer(x, np.int8))
    return codebook_df</code></pre>
</details>
</dd>
<dt id="pysmFISH.barcodes_analysis.decoder_fun"><code class="name flex">
<span>def <span class="ident">decoder_fun</span></span>(<span>registered_counts, analysis_parameters, experiment_info, codebook_df)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decoder_fun(registered_counts, analysis_parameters,experiment_info,codebook_df):
    dc = extract_barcodes_NN_new(registered_counts, analysis_parameters,experiment_info,codebook_df)
    dc.run_extraction()
    return dc.all_combine_df</code></pre>
</details>
</dd>
<dt id="pysmFISH.barcodes_analysis.define_flip_direction"><code class="name flex">
<span>def <span class="ident">define_flip_direction</span></span>(<span>codebook_dict: dict, experiment_fpath: str, output_df: pandas.core.frame.DataFrame)</span>
</code></dt>
<dd>
<div class="desc"><p>Function used to determinethe the position of the bits that are
flipped after the nearest neighbors and the definition of the
acceptable hamming distance for fov.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>codebook</code></strong> :&ensp;<code>dict</code></dt>
<dd>Codebooks used for the decoding</dd>
<dt><strong><code>experiment_fpath</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the folder of the experiment to process</dd>
<dt><strong><code>output_df</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>Dataframe with the decoded results for
the specific fov.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def define_flip_direction(codebook_dict: dict,experiment_fpath: str, 
            output_df: pd.DataFrame):
    &#34;&#34;&#34;Function used to determinethe the position of the bits that are
    flipped after the nearest neighbors and the definition of the
    acceptable hamming distance for fov.

    Args:
        codebook (dict): Codebooks used for the decoding
        experiment_fpath (str): Path to the folder of the experiment to process
        output_df (pd.DataFrame): Dataframe with the decoded results for 
                    the specific fov.
    &#34;&#34;&#34;
    if output_df.shape[0] &gt; 1:
        correct_hamming_distance = 0
        selected_hamming_distance = 3 / output_df.iloc[0].barcode_length
        experiment_fpath = Path(experiment_fpath)
        experiment_name = experiment_fpath.stem
        channels = codebook_dict.keys()
        all_evaluated = []
        for channel in channels: 
            codebook = codebook_dict[channel]
            fov = output_df.fov_num.values[0]
            trimmed_df = output_df.loc[(output_df.dot_id == output_df.barcode_reference_dot_id) &amp;
                                (output_df.channel == channel) &amp;
                                (output_df[&#39;hamming_distance&#39;] &gt; correct_hamming_distance) &amp;
                                (output_df[&#39;hamming_distance&#39;] &lt; selected_hamming_distance),
                                    [&#39;barcode_reference_dot_id&#39;, &#39;decoded_genes&#39;, &#39;raw_barcodes&#39;,&#39;hamming_distance&#39;]]
            trimmed_df = trimmed_df.dropna(subset=[&#39;decoded_genes&#39;])
            trimmed_df.loc[:,(&#39;flip_and_direction&#39;)] = trimmed_df.apply(lambda x: identify_flipped_bits(codebook,x.decoded_genes,x.raw_barcodes),axis=1)
            trimmed_df[&#39;flip_position&#39;] = trimmed_df[&#39;flip_and_direction&#39;].apply(lambda x: x[0])
            trimmed_df[&#39;flip_direction&#39;] = trimmed_df[&#39;flip_and_direction&#39;].apply(lambda x: x[1])
            trimmed_df.drop(columns=[&#39;flip_and_direction&#39;],inplace=True)
            all_evaluated.append(trimmed_df)
        
        all_evaluated = pd.concat(all_evaluated,axis=0,ignore_index=True,inplace=True)

        
        fpath = experiment_fpath / &#39;results&#39; / (experiment_name + &#39;_&#39; + channel + &#39;_df_flip_direction_fov&#39; + str(fov) + &#39;.parquet&#39;)
        all_evaluated.to_parquet(fpath)</code></pre>
</details>
</dd>
<dt id="pysmFISH.barcodes_analysis.dots_hoods"><code class="name flex">
<span>def <span class="ident">dots_hoods</span></span>(<span>coords: numpy.ndarray, pxl: int) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Function that calculate the coords of the peaks searching
neighborhood for identifying the barcodes.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>coords</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>coords of the identified peaks</dd>
<dt><strong><code>pxl</code></strong> :&ensp;<code>int</code></dt>
<dd>size of the neighborhood in pixel</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>coords that define the neighborhood (r_tl,r_br,c_tl,c_tr)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dots_hoods(coords: np.ndarray,pxl: int)-&gt;np.ndarray:
    &#34;&#34;&#34;Function that calculate the coords of the peaks searching
    neighborhood for identifying the barcodes.

    Args:
        coords (np.ndarray): coords of the identified peaks
        pxl (int): size of the neighborhood in pixel

    Returns:
        np.ndarray: coords that define the neighborhood (r_tl,r_br,c_tl,c_tr)
    &#34;&#34;&#34;
    r_tl = coords[:,0]-pxl
    r_br = coords[:,0]+pxl
    c_tl = coords[:,1]-pxl
    c_tr = coords[:,1]+pxl
    r_tl = r_tl[:,np.newaxis]
    r_br = r_br[:,np.newaxis]
    c_tl = c_tl[:,np.newaxis]
    c_tr = c_tr[:,np.newaxis]
    chunks_coords = np.hstack((r_tl,r_br,c_tl,c_tr))
    chunks_coords = chunks_coords.astype(int)
    return chunks_coords</code></pre>
</details>
</dd>
<dt id="pysmFISH.barcodes_analysis.extract_barcodes_NN_fast"><code class="name flex">
<span>def <span class="ident">extract_barcodes_NN_fast</span></span>(<span>registered_counts_df, analysis_parameters: Dict, codebook_df)</span>
</code></dt>
<dd>
<div class="desc"><p>Class used to extract the barcodes from the registered
counts using nearest neighbour</p>
<h2 id="parameters">Parameters:</h2>
<p>counts: pandas.DataFrame
pandas file with the fov counts after
registration
analysis_parameters: dict
parameters for data processing
codebook_df: pandas.DataFrame
pandas file with the codebook used to
deconvolve the barcode</p>
<p>NB: if there is a problem with the registration the barcode assigned
will be 0*barcode_length</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_barcodes_NN_fast(registered_counts_df, analysis_parameters:Dict,codebook_df):
    &#34;&#34;&#34;
    Class used to extract the barcodes from the registered
    counts using nearest neighbour

    Parameters:
    -----------
    counts: pandas.DataFrame
        pandas file with the fov counts after
        registration
    analysis_parameters: dict
        parameters for data processing 
    codebook_df: pandas.DataFrame
        pandas file with the codebook used to
        deconvolve the barcode

    NB: if there is a problem with the registration the barcode assigned 
        will be 0*barcode_length
    
    &#34;&#34;&#34;

    logger = selected_logger()

    barcodes_extraction_resolution = analysis_parameters[&#39;BarcodesExtractionResolution&#39;]
    RegistrationMinMatchingBeads = analysis_parameters[&#39;RegistrationMinMatchingBeads&#39;]
    barcode_length = registered_counts_df.loc[0][&#39;barcode_length&#39;]
    registration_errors = Registration_errors()

    stitching_channel = registered_counts_df[&#39;stitching_channel&#39;].iloc[0]
    
    fish_counts = registered_counts_df.loc[registered_counts_df.channel != stitching_channel,:]
    stitching_channel_counts = registered_counts_df.loc[registered_counts_df.channel == stitching_channel,:]
    
    fish_counts.dropna(subset=[&#39;dot_id&#39;],inplace=True)
    # Starting level for selection of dots
    dropping_counts = fish_counts.copy(deep=True)

    all_decoded_dots_list = []

    if fish_counts[&#39;r_px_registered&#39;].isnull().values.any():
        
        all_decoded_dots_df = pd.DataFrame(columns = fish_counts.columns)
        all_decoded_dots_df[&#39;decoded_genes&#39;] = np.nan
        all_decoded_dots_df[&#39;hamming_distance&#39;] = np.nan
        all_decoded_dots_df[&#39;number_positive_bits&#39;] = np.nan
        all_decoded_dots_df[&#39;barcode_reference_dot_id&#39;] = np.nan
        all_decoded_dots_df[&#39;raw_barcodes&#39;] = np.nan
        all_decoded_dots_df[&#39;barcodes_extraction_resolution&#39;] = barcodes_extraction_resolution
        # Save barcoded_round and all_decoded_dots_df
        return fish_counts, all_decoded_dots_df
        
    else:
    
        for ref_round_number in np.arange(1,barcode_length+1):

            #ref_round_number = 1
            reference_round_df = dropping_counts.loc[dropping_counts.round_num == ref_round_number,:]
            # Step one (all dots not in round 1)
            compare_df = dropping_counts.loc[dropping_counts.round_num != ref_round_number,:]

            if (not reference_round_df.empty) and (not compare_df.empty):
                nn = NearestNeighbors(n_neighbors=1, metric=&#34;euclidean&#34;)
                nn.fit(reference_round_df[[&#39;r_px_registered&#39;,&#39;c_px_registered&#39;]])
                dists, indices = nn.kneighbors(compare_df[[&#39;r_px_registered&#39;,&#39;c_px_registered&#39;]], return_distance=True)

                # select only the nn that are below barcodes_extraction_resolution distance
                idx_distances_below_resolution = np.where(dists &lt;= barcodes_extraction_resolution)[0]

                comp_idx = idx_distances_below_resolution
                ref_idx = indices[comp_idx].flatten()

                # Subset the dataframe according to the selected points
                # The reference selected will have repeated points
                comp_selected_df = compare_df.iloc[comp_idx]
                ref_selected_df = reference_round_df.iloc[ref_idx]

               # The size of ref_selected_df w/o duplicates may be smaller of reference_round_df if 
                # some of the dots in reference_round_df have no neighbours

                # Test approach where we get rid of the single dots
                comp_selected_df.loc[:,&#39;barcode_reference_dot_id&#39;] = ref_selected_df[&#39;dot_id&#39;].values
                ref_selected_df_no_duplicates = ref_selected_df.drop_duplicates()
                ref_selected_df_no_duplicates.loc[:,&#39;barcode_reference_dot_id&#39;] = ref_selected_df_no_duplicates[&#39;dot_id&#39;].values

                barcoded_round = pd.concat([comp_selected_df, ref_selected_df_no_duplicates], axis=0,ignore_index=False)
                barcoded_round_grouped = barcoded_round.groupby(&#39;barcode_reference_dot_id&#39;)
                for brdi, grp in barcoded_round_grouped:
                    barcode = np.zeros([barcode_length],dtype=np.int8)
                    barcode[grp.round_num.values.astype(np.int8)-1] = 1
                    #hamming_dist, index_gene = nn_sklearn.kneighbors(barcode.reshape(1, -1), return_distance=True)
                    #gene= codebook_df.loc[index_gene.reshape(index_gene.shape[0]),&#39;Gene&#39;].tolist()

                    barcode = barcode.tostring()
                    ref_selected_df_no_duplicates.loc[ref_selected_df_no_duplicates.barcode_reference_dot_id == brdi,&#39;raw_barcodes&#39;] = barcode
                    #ref_selected_df_no_duplicates.loc[ref_selected_df_no_duplicates.barcode_reference_dot_id == brdi,&#39;decoded_gene_name&#39;] = gene
                    #ref_selected_df_no_duplicates.loc[ref_selected_df_no_duplicates.barcode_reference_dot_id == brdi,&#39;hamming_distance&#39;] = hamming_dist.flatten()[0]

                    #fish_counts.loc[grp.index,&#39;barcode_reference_dot_id&#39;] = brdi
                    #fish_counts.loc[grp.index,&#39;raw_barcodes&#39;] = barcode
                    #dists, index = nn_sklearn.kneighbors(all_barcodes, return_distance=True)

                all_decoded_dots_list.append(ref_selected_df_no_duplicates)

                all_decoded_dots_df = pd.concat(all_decoded_dots_list,ignore_index=False)
                
                compare_df = compare_df.drop(comp_selected_df.index)
                dropping_counts = compare_df

        codebook_df = convert_str_codebook(codebook_df,&#39;Code&#39;)
        codebook_array = make_codebook_array(codebook_df,&#39;Code&#39;)
        nn_sklearn = NearestNeighbors(n_neighbors=1, metric=&#34;hamming&#34;)
        nn_sklearn.fit(codebook_array)

        all_barcodes = np.vstack(all_decoded_dots_df.raw_barcodes.map(lambda x: np.frombuffer(x, np.int8)).values)
        dists_arr, index_arr = nn_sklearn.kneighbors(all_barcodes, return_distance=True)
        genes=codebook_df.loc[index_arr.reshape(index_arr.shape[0]),&#39;Gene&#39;].tolist()

        all_decoded_dots_df.loc[:,&#39;decoded_genes&#39;] = genes
        all_decoded_dots_df.loc[:,&#39;hamming_distance&#39;] = dists_arr
        all_decoded_dots_df.loc[:,&#39;number_positive_bits&#39;] = all_barcodes.sum(axis=1)

        all_decoded_dots_df = pd.concat([all_decoded_dots_df,stitching_channel_counts])
        all_decoded_dots_df[&#39;barcodes_extraction_resolution&#39;] = barcodes_extraction_resolution

        # Save barcoded_round and all_decoded_dots_df
        return barcoded_round, all_decoded_dots_df</code></pre>
</details>
</dd>
<dt id="pysmFISH.barcodes_analysis.extract_barcodes_NN_fast_multicolor"><code class="name flex">
<span>def <span class="ident">extract_barcodes_NN_fast_multicolor</span></span>(<span>registered_counts_df: pandas.core.frame.DataFrame, analysis_parameters: Dict, codebook_df: pandas.core.frame.DataFrame, metadata: dict) ‑> Tuple[pandas.core.frame.DataFrame, pandas.core.frame.DataFrame]</span>
</code></dt>
<dd>
<div class="desc"><p>Function used to extract the barcodes from the registered
counts using nearest neighbour. if there is a problem with the registration the barcode assigned
will be 0*barcode_length</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>registered_counts_df</code></strong> :&ensp;<code>pd.Dataframe</code></dt>
<dd>Fov counts after registration</dd>
<dt><strong><code>analysis_parameters</code></strong> :&ensp;<code>Dict</code></dt>
<dd>Parameters for data processing </dd>
<dt><strong><code>codebook_df</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>codebook used to deconvolve the barcode</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[pd.DataFrame,pd.DataFrame]</code></dt>
<dd>(barcoded_round, all_decoded_dots_df)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_barcodes_NN_fast_multicolor(registered_counts_df: pd.DataFrame, analysis_parameters: Dict,
                codebook_df: pd.DataFrame, metadata:dict)-&gt; Tuple[pd.DataFrame,pd.DataFrame]:
    &#34;&#34;&#34;Function used to extract the barcodes from the registered
    counts using nearest neighbour. if there is a problem with the registration the barcode assigned 
    will be 0*barcode_length

    Args:
        registered_counts_df (pd.Dataframe): Fov counts after registration
        analysis_parameters (Dict): Parameters for data processing 
        codebook_df (pd.DataFrame): codebook used to deconvolve the barcode
    Returns:
        Tuple[pd.DataFrame,pd.DataFrame]: (barcoded_round, all_decoded_dots_df)
    &#34;&#34;&#34;

    logger = selected_logger()

    barcodes_extraction_resolution = analysis_parameters[&#39;BarcodesExtractionResolution&#39;]
    RegistrationMinMatchingBeads = analysis_parameters[&#39;RegistrationMinMatchingBeads&#39;]
    barcode_length = metadata[&#39;barcode_length&#39;]
    registration_errors = Registration_errors()

    stitching_channel = metadata[&#39;stitching_channel&#39;]
    
 
    registered_counts_df.dropna(subset=[&#39;dot_id&#39;],inplace=True)
    # Starting level for selection of dots
    dropping_counts = registered_counts_df.copy(deep=True)

    all_decoded_dots_list = []
    barcoded_round = []
    if registered_counts_df[&#39;r_px_registered&#39;].isnull().values.any():
        
        all_decoded_dots_df = pd.DataFrame(columns = registered_counts_df.columns)
        all_decoded_dots_df[&#39;decoded_genes&#39;] = np.nan
        all_decoded_dots_df[&#39;hamming_distance&#39;] = np.nan
        all_decoded_dots_df[&#39;number_positive_bits&#39;] = np.nan
        all_decoded_dots_df[&#39;barcode_reference_dot_id&#39;] = np.nan
        all_decoded_dots_df[&#39;raw_barcodes&#39;] = np.nan
        all_decoded_dots_df[&#39;barcodes_extraction_resolution&#39;] = barcodes_extraction_resolution
        # Save barcoded_round and all_decoded_dots_df
        return registered_counts_df, all_decoded_dots_df
        
    else:
        for ref_round_number in np.arange(1,barcode_length+1):

            #ref_round_number = 1
            reference_round_df = dropping_counts.loc[dropping_counts.round_num == ref_round_number,:]
            # Step one (all dots not in round 1)
            compare_df = dropping_counts.loc[dropping_counts.round_num!=ref_round_number,:]

            if (not reference_round_df.empty):
                if not compare_df.empty:
                    nn = NearestNeighbors(n_neighbors=1, metric=&#34;euclidean&#34;)
                    nn.fit(reference_round_df[[&#39;r_px_registered&#39;,&#39;c_px_registered&#39;]])
                    dists, indices = nn.kneighbors(compare_df[[&#39;r_px_registered&#39;,&#39;c_px_registered&#39;]], return_distance=True)

                    # select only the nn that are below barcodes_extraction_resolution distance
                    idx_distances_below_resolution = np.where(dists &lt;= barcodes_extraction_resolution)[0]

                    comp_idx = idx_distances_below_resolution
                    ref_idx = indices[comp_idx].flatten()

                    # Subset the dataframe according to the selected points
                    # The reference selected will have repeated points
                    comp_selected_df = compare_df.iloc[comp_idx]
                    ref_selected_df = reference_round_df.iloc[ref_idx]

                    # The size of ref_selected_df w/o duplicates may be smaller of reference_round_df if 
                    # some of the dots in reference_round_df have no neighbours

                    # Test approach where we get rid of the single dots
                    comp_selected_df.loc[:,&#39;barcode_reference_dot_id&#39;] = ref_selected_df[&#39;dot_id&#39;].values
                    ref_selected_df_no_duplicates = ref_selected_df.drop_duplicates()
                    ref_selected_df_no_duplicates.loc[:,&#39;barcode_reference_dot_id&#39;] = ref_selected_df_no_duplicates[&#39;dot_id&#39;].values

                    # Collect singletons
                    # Remeber that this method works only because there are no duplicates inside the dataframes
                    # https://stackoverflow.com/questions/48647534/python-pandas-find-difference-between-two-data-frames
                    if reference_round_df.shape[0] &gt; ref_selected_df_no_duplicates.shape[0]:
                        singletons_df = pd.concat([reference_round_df,ref_selected_df_no_duplicates]).drop_duplicates(keep=False)
                        singletons_df.loc[:,&#39;barcode_reference_dot_id&#39;] = singletons_df[&#39;dot_id&#39;].values
                        barcoded_round = pd.concat([comp_selected_df, ref_selected_df_no_duplicates,singletons_df], axis=0,ignore_index=False)
                    else:
                        barcoded_round = pd.concat([comp_selected_df, ref_selected_df_no_duplicates], axis=0,ignore_index=False)

                    barcoded_round = pd.concat([comp_selected_df, ref_selected_df_no_duplicates,singletons_df], axis=0,ignore_index=False)
                    barcoded_round_grouped = barcoded_round.groupby(&#39;barcode_reference_dot_id&#39;)

                    compare_df = compare_df.drop(comp_selected_df.index)
                    dropping_counts = compare_df

                else:
                    # Collecting singleton of last bit
                    reference_round_df.loc[:,&#39;barcode_reference_dot_id&#39;] = reference_round_df[&#39;dot_id&#39;].values
                    barcoded_round_grouped = reference_round_df.groupby(&#39;barcode_reference_dot_id&#39;)
                    ref_selected_df_no_duplicates = reference_round_df

                for brdi, grp in barcoded_round_grouped:
                    barcode = np.zeros([barcode_length],dtype=np.int8)
                    barcode[grp.round_num.values.astype(np.int8)-1] = 1
                    #hamming_dist, index_gene = nn_sklearn.kneighbors(barcode.reshape(1, -1), return_distance=True)
                    #gene= codebook_df.loc[index_gene.reshape(index_gene.shape[0]),&#39;Gene&#39;].tolist()

                    barcode = barcode.tostring()
                    if len(ref_selected_df_no_duplicates) !=  0:
                        ref_selected_df_no_duplicates.loc[ref_selected_df_no_duplicates.barcode_reference_dot_id == brdi,&#39;raw_barcodes&#39;] = barcode
                    #ref_selected_df_no_duplicates.loc[ref_selected_df_no_duplicates.barcode_reference_dot_id == brdi,&#39;decoded_gene_name&#39;] = gene
                    #ref_selected_df_no_duplicates.loc[ref_selected_df_no_duplicates.barcode_reference_dot_id == brdi,&#39;hamming_distance&#39;] = hamming_dist.flatten()[0]

                    #fish_counts.loc[grp.index,&#39;barcode_reference_dot_id&#39;] = brdi
                    #fish_counts.loc[grp.index,&#39;raw_barcodes&#39;] = barcode
                    #dists, index = nn_sklearn.kneighbors(all_barcodes, return_distance=True)

                all_decoded_dots_list.append(ref_selected_df_no_duplicates)

        if all_decoded_dots_list:
            all_decoded_dots_df = pd.concat(all_decoded_dots_list,ignore_index=False)
                    
                
            codebook_df = convert_str_codebook(codebook_df,&#39;Code&#39;)
            codebook_array = make_codebook_array(codebook_df,&#39;Code&#39;)
            nn_sklearn = NearestNeighbors(n_neighbors=1, metric=&#34;hamming&#34;)
            nn_sklearn.fit(codebook_array)

            all_barcodes = np.vstack(all_decoded_dots_df.raw_barcodes.map(lambda x: np.frombuffer(x, np.int8)).values)
            dists_arr, index_arr = nn_sklearn.kneighbors(all_barcodes, return_distance=True)
            genes=codebook_df.loc[index_arr.reshape(index_arr.shape[0]),&#39;Gene&#39;].tolist()

            all_decoded_dots_df.loc[:,&#39;decoded_genes&#39;] = genes
            all_decoded_dots_df.loc[:,&#39;hamming_distance&#39;] = dists_arr
            all_decoded_dots_df.loc[:,&#39;number_positive_bits&#39;] = all_barcodes.sum(axis=1)

            all_decoded_dots_df[&#39;barcodes_extraction_resolution&#39;] = barcodes_extraction_resolution
        else:
            all_decoded_dots_df = pd.DataFrame(columns = registered_counts_df.columns)
            all_decoded_dots_df[&#39;decoded_genes&#39;] = np.nan
            all_decoded_dots_df[&#39;hamming_distance&#39;] = np.nan
            all_decoded_dots_df[&#39;number_positive_bits&#39;] = np.nan
            all_decoded_dots_df[&#39;barcode_reference_dot_id&#39;] = np.nan
            all_decoded_dots_df[&#39;raw_barcodes&#39;] = np.nan
            all_decoded_dots_df[&#39;barcodes_extraction_resolution&#39;] = barcodes_extraction_resolution

        
        # Save barcoded_round and all_decoded_dots_df
        return barcoded_round, all_decoded_dots_df</code></pre>
</details>
</dd>
<dt id="pysmFISH.barcodes_analysis.extract_dots_images"><code class="name flex">
<span>def <span class="ident">extract_dots_images</span></span>(<span>barcoded_df: pandas.core.frame.DataFrame, registered_img_stack: numpy.ndarray, experiment_fpath: str, metadata: dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Function used to extract the images corresponding to a barcode
after running the decoding identification. It can save the images
but to avoid increasing too much the space occupied by a processed
experiment an array with the maximum intensity value of the pxl in
each round is calculated and saved </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>barcoded_df</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>Dataframe with decoded barcodes
for a specific field of view.</dd>
<dt><strong><code>registered_img_stack</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>Preprocessed image of a single field of view
the imaging round correspond to the z-stack position</dd>
<dt><strong><code>experiment_fpath</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the folder of the experiment to process</dd>
<dt><strong><code>metadata</code></strong> :&ensp;<code>dict</code></dt>
<dd>Overall experiment info</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_dots_images(barcoded_df: pd.DataFrame,registered_img_stack: np.ndarray,
                experiment_fpath: str, metadata: dict):
    &#34;&#34;&#34;Function used to extract the images corresponding to a barcode
    after running the decoding identification. It can save the images
    but to avoid increasing too much the space occupied by a processed
    experiment an array with the maximum intensity value of the pxl in
    each round is calculated and saved 

    Args:
        barcoded_df (pd.DataFrame): Dataframe with decoded barcodes 
                    for a specific field of view.
        registered_img_stack (np.ndarray): Preprocessed image of a single field of view
                    the imaging round correspond to the z-stack position
        experiment_fpath (str): Path to the folder of the experiment to process
        metadata (dict): Overall experiment info
    &#34;&#34;&#34;
    
    round_intensity_labels = [&#39;bit_&#39; + str(el) +&#39;_intensity&#39; for el in np.arange(1,int(metadata[&#39;total_rounds&#39;])+1)]
    
    if isinstance(registered_img_stack, np.ndarray) and (barcoded_df.shape[0] &gt;1):
        experiment_fpath = Path(experiment_fpath)
          
        barcodes_names = barcoded_df[&#39;barcode_reference_dot_id&#39;].values
        coords = barcoded_df.loc[:, [&#39;r_px_registered&#39;, &#39;c_px_registered&#39;]].to_numpy()
        barcodes_extraction_resolution = barcoded_df[&#39;barcodes_extraction_resolution&#39;].values[0]

        chunks_coords = dots_hoods(coords,barcodes_extraction_resolution)
        chunks_coords[chunks_coords&lt;0]=0
        chunks_coords[chunks_coords&gt;registered_img_stack.shape[1]]= registered_img_stack.shape[1]
    
        for idx in np.arange(chunks_coords.shape[0]):
            selected_region = registered_img_stack[:,chunks_coords[idx,0]:chunks_coords[idx,1]+1,chunks_coords[idx,2]:chunks_coords[idx,3]+1]
            if selected_region.size &gt;0:
                max_array = selected_region.max(axis=(1,2))
                barcoded_df.loc[barcoded_df.dot_id == barcodes_names[idx],round_intensity_labels] = max_array


        # for channel in channels:
            # all_regions[channel] = {}
            # all_max[channel] = {}
            # img_stack = registered_img_stack[channel]
            # trimmed_df_channel = trimmed_df.loc[trimmed_df.channel == channel]
            # if trimmed_df_channel.shape[0] &gt;0:

            #     barcodes_names = trimmed_df_channel[&#39;barcode_reference_dot_id&#39;].values
            #     coords = trimmed_df_channel.loc[:, [&#39;r_px_registered&#39;, &#39;c_px_registered&#39;]].to_numpy()
            #     barcodes_extraction_resolution = trimmed_df_channel[&#39;barcodes_extraction_resolution&#39;].values[0]

            #     chunks_coords = dots_hoods(coords,barcodes_extraction_resolution)
            #     chunks_coords[chunks_coords&lt;0]=0
            #     chunks_coords[chunks_coords&gt;img_stack.shape[1]]= img_stack.shape[1]
            
            
            #     for idx in np.arange(chunks_coords.shape[0]):
            #         selected_region = img_stack[:,chunks_coords[idx,0]:chunks_coords[idx,1]+1,chunks_coords[idx,2]:chunks_coords[idx,3]+1]
            #         if selected_region.size &gt;0:
            #             max_array = selected_region.max(axis=(1,2))
            #             # all_regions[channel][barcodes_names[idx]]= selected_region
            #             all_max[channel][barcodes_names[idx]]= max_array
            #             barcoded_df.loc[barcoded_df.dot_id == barcodes_names[idx],round_intensity_labels] = max_array

        # fpath = experiment_fpath / &#39;tmp&#39; / &#39;combined_rounds_images&#39; / (experiment_name + &#39;_&#39; + channel + &#39;_img_dict_fov_&#39; + str(fov) + &#39;.pkl&#39;)
        # pickle.dump(all_regions,open(fpath,&#39;wb&#39;))
        # fpath = experiment_fpath / &#39;results&#39; / (experiment_name + &#39;_barcodes_max_array_dict_fov_&#39; + str(fov) + &#39;.pkl&#39;)
        # pickle.dump(all_max,open(fpath,&#39;wb&#39;))
    
    else:
        barcoded_df.loc[:,round_intensity_labels] = np.nan
    
    return barcoded_df</code></pre>
</details>
</dd>
<dt id="pysmFISH.barcodes_analysis.identify_flipped_bits"><code class="name flex">
<span>def <span class="ident">identify_flipped_bits</span></span>(<span>codebook: pandas.core.frame.DataFrame, gene: str, raw_barcode: ByteString) ‑> Tuple[ByteString, ByteString]</span>
</code></dt>
<dd>
<div class="desc"><p>Utility function used to identify the position of the bits that are
flipped after the nearest neighbors and the definition of the
acceptable hamming distance for a single dot.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>codebook</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>Codebook used for the decoding</dd>
<dt><strong><code>gene</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the gene identified</dd>
<dt><strong><code>raw_barcode</code></strong> :&ensp;<code>ByteString</code></dt>
<dd>identifide barcode from the images</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[ByteString, ByteString]</code></dt>
<dd>(flipped_position, flipping_direction)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def identify_flipped_bits(codebook: pd.DataFrame, gene: str, 
                    raw_barcode: ByteString)-&gt; Tuple[ByteString, ByteString]:
    &#34;&#34;&#34;Utility function used to identify the position of the bits that are
    flipped after the nearest neighbors and the definition of the
    acceptable hamming distance for a single dot.

    Args:
        codebook (pd.DataFrame): Codebook used for the decoding
        gene (str): Name of the gene identified
        raw_barcode (ByteString): identifide barcode from the images

    Returns:
        Tuple[ByteString, ByteString]: (flipped_position, flipping_direction)
    &#34;&#34;&#34;
    gene_barcode_str =codebook.loc[codebook.Gene == gene, &#39;Code&#39;].values[0]
    gene_barcode = np.frombuffer(gene_barcode_str, np.int8)
    raw_barcode = np.frombuffer(raw_barcode, np.int8)
    flipped_positions = np.where(raw_barcode != gene_barcode)[0].astype(np.int8)
    flipping_directions = (gene_barcode[flipped_positions] - raw_barcode[flipped_positions]).astype(np.int8)
    # flipped_positions = flipped_positions.tobytes()
    # flipping_directions = flipping_directions.tobytes()
    return flipped_positions,flipping_directions</code></pre>
</details>
</dd>
<dt id="pysmFISH.barcodes_analysis.make_codebook_array"><code class="name flex">
<span>def <span class="ident">make_codebook_array</span></span>(<span>codebook_df, column_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_codebook_array(codebook_df,column_name):
    codebook_array = np.zeros((len(codebook_df[column_name]),codebook_df[column_name][0].shape[0]))
    for idx, el in enumerate(codebook_df[column_name]):
        row = codebook_df[column_name][idx]
        row = row[np.newaxis,:]
        codebook_array[idx,:] = row
    return codebook_array</code></pre>
</details>
</dd>
<dt id="pysmFISH.barcodes_analysis.merge_with_concat"><code class="name flex">
<span>def <span class="ident">merge_with_concat</span></span>(<span>dfs: list) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Utility function used to merge dataframes</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dsf</code></strong> :&ensp;<code>list</code></dt>
<dd>List with the dataframe to merge</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>Merged dataframe</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge_with_concat(dfs: list)-&gt;pd.DataFrame:
    &#34;&#34;&#34;Utility function used to merge dataframes

    Args:
        dsf (list): List with the dataframe to merge

    Returns:
        pd.DataFrame: Merged dataframe
    &#34;&#34;&#34;                                           

#     dfs = (df.set_index(col, drop=True) for df in dfs)
    merged = pd.concat(dfs, axis=0, join=&#39;outer&#39;, copy=False)
    return merged</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pysmFISH.barcodes_analysis.extract_barcodes"><code class="flex name class">
<span>class <span class="ident">extract_barcodes</span></span>
<span>(</span><span>counts, pxl: int, save=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Class used to extract the barcodes from the registered
counts</p>
<h2 id="parameters">Parameters:</h2>
<p>counts: pandas dataframe
contains all the counts for a fov
pxl: int
size of the hood to search for positive
barcodes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class extract_barcodes():
    &#34;&#34;&#34;
    Class used to extract the barcodes from the registered
    counts

    Parameters:
    -----------
    counts: pandas dataframe
        contains all the counts for a fov
    pxl: int
        size of the hood to search for positive
        barcodes
    &#34;&#34;&#34;

    def __init__(self, counts, pxl:int,save=True):
        self.counts = counts
        self.pxl = pxl
        self.save = save

        self.logger = logging.getLogger(__name__)

    @staticmethod
    def combine_coords(counts, round_num, counts_type=&#39;registered&#39;):
        data_reference = counts.loc[counts[&#39;round_num&#39;] == round_num]
        if counts_type == &#39;registered&#39;:
            r_px = data_reference.r_px_registered.to_list()
            c_px = data_reference.c_px_registered.to_list()
        elif counts_type == &#39;original&#39;:
            r_px = data_reference.r_px_original.to_list()
            c_px = data_reference.c_px_original.to_list()
        coords = np.array(list(zip(r_px,c_px)))
        position_idx = data_reference.index
        return coords, position_idx
    
    @staticmethod
    def dots_hoods(coords,pxl):
        r_tl = coords[:,0]-pxl
        r_br = coords[:,0]+pxl
        c_tl = coords[:,1]-pxl
        c_tr = coords[:,1]+pxl
        r_tl = r_tl[:,np.newaxis]
        r_br = r_br[:,np.newaxis]
        c_tl = c_tl[:,np.newaxis]
        c_tr = c_tr[:,np.newaxis]
        chunks_coords = np.hstack((r_tl,r_br,c_tl,c_tr))
        chunks_coords = chunks_coords.astype(int)
        return chunks_coords

    @staticmethod
    def barcode_detection(all_coords_image,chunk_coords,pxl):
        selected_region = all_coords_image[:,chunk_coords[0]:chunk_coords[1]+1,chunk_coords[2]:chunk_coords[3]+1]
        barcode = np.sum(selected_region, axis=(1,2))
        return barcode, selected_region

    def run_extraction(self):
        # add check to make sure that the counts are there
        column_names = [&#39;r_px_original&#39;,&#39;c_px_original&#39;,&#39;dot_id&#39;,&#39;fov_num&#39;,&#39;round_num&#39;,&#39;dot_intensity_norm&#39;,
                        &#39;dot_intensity_not&#39;,&#39;selected_thr&#39; ,&#39;channel&#39;,&#39;r_shift&#39;,&#39;c_shift&#39;,&#39;r_px_registered&#39;,
                        &#39;c_px_registered&#39;,&#39;pixel_microns&#39;]
        column_names_output = column_names.copy()
        column_names_output.append(&#39;pxl_hood_size&#39;)
        column_names_output.append(&#39;raw_barcodes&#39;)
        self.barcodes_binary_images = {}
        if len(self.counts[&#39;r_px_registered&#39;]) &gt; 1:
            r_num = int(self.counts[&#39;r_px_registered&#39;].max())
            c_num = int(self.counts[&#39;c_px_registered&#39;].max())
            rounds_num = len(self.counts[&#39;round_num&#39;].unique())
            all_coords_image = np.zeros([rounds_num,r_num+1,c_num+1],dtype=np.int8)
            for round_num in np.arange(1,rounds_num+1):
                coords, ref_position_idx = self.combine_coords(self.counts, round_num, counts_type=&#39;registered&#39;)
                if np.any(np.isnan(coords)):
                    stop = True
                    break
                else:
                    stop = False
                    coords = coords.astype(np.int)
                    all_coords_image[round_num-1,coords[:,0],coords[:,1]] = 1

            if stop:
                self.logger.error(f&#39;missing round {coords} no barcodes&#39;)
                self.output = pd.DataFrame(np.nan,index=[0],columns = column_names_output)
            else:
                self.output = pd.DataFrame(columns = column_names_output)
                self.output[&#39;pxl_hood_size&#39;] = np.nan
                self.output[&#39;raw_barcodes&#39;] = np.nan
                # self.raw_barcodes = []
                for round_num in np.arange(1,rounds_num+1):
                    coords, ref_position_idx = self.combine_coords(self.counts, round_num, counts_type=&#39;registered&#39;)
                    dot_ids = self.counts.loc[ref_position_idx,&#39;dot_id&#39;]
                    dot_ids = dot_ids.reset_index()
                    chunks_coords = self.dots_hoods(coords,self.pxl)
                    for row in np.arange(coords.shape[0]):
                        chunk = chunks_coords[row,:]
                        dot_id = dot_ids.loc[row,&#39;dot_id&#39;]
                        selected_dot_coords = coords[row,:].astype(int)
                        barcode,selected_region = self.barcode_detection(all_coords_image,chunk,self.pxl)
                        # Add only the barcodes that are not all negatives (can happen because I am blanking the img)
                        if barcode.sum():
                            self.barcodes_binary_images[dot_id] = {}
                            self.barcodes_binary_images[dot_id][&#39;img&#39;] = selected_region
                            self.barcodes_binary_images[dot_id][&#39;raw_barcode&#39;] = barcode
                            # self.raw_barcodes.append(barcode)
                            # Blank the image
                            all_coords_image[:,selected_dot_coords[0],selected_dot_coords[1]] = 0
                            dot_data = self.counts[(self.counts[&#39;round_num&#39;] == round_num) &amp; (self.counts[&#39;r_px_registered&#39;] == selected_dot_coords[0]) &amp; (self.counts[&#39;c_px_registered&#39;] == selected_dot_coords[1])] 
                            barcode_st = &#39;&#39;
                            barcode_st = barcode_st.join([&#34;,&#34;.join(item) for item in barcode.astype(str)])
                            dot_data.insert(0,&#39;raw_barcodes&#39;,barcode_st)
                            dot_data.insert(0,&#39;pxl_hood_size&#39;,self.pxl)
                            self.output = pd.concat([self.output,dot_data],axis=0,ignore_index=True)
        
                # self.output[&#39;pxl_hood_size&#39;] = self.pxl
                # self.output[&#39;raw_barcodes&#39;] = self.raw_barcodes
        else:
            if self.save:
                self.output = pd.DataFrame(np.nan,index=[0],columns = column_names_output)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="pysmFISH.barcodes_analysis.extract_barcodes.barcode_detection"><code class="name flex">
<span>def <span class="ident">barcode_detection</span></span>(<span>all_coords_image, chunk_coords, pxl)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def barcode_detection(all_coords_image,chunk_coords,pxl):
    selected_region = all_coords_image[:,chunk_coords[0]:chunk_coords[1]+1,chunk_coords[2]:chunk_coords[3]+1]
    barcode = np.sum(selected_region, axis=(1,2))
    return barcode, selected_region</code></pre>
</details>
</dd>
<dt id="pysmFISH.barcodes_analysis.extract_barcodes.combine_coords"><code class="name flex">
<span>def <span class="ident">combine_coords</span></span>(<span>counts, round_num, counts_type='registered')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def combine_coords(counts, round_num, counts_type=&#39;registered&#39;):
    data_reference = counts.loc[counts[&#39;round_num&#39;] == round_num]
    if counts_type == &#39;registered&#39;:
        r_px = data_reference.r_px_registered.to_list()
        c_px = data_reference.c_px_registered.to_list()
    elif counts_type == &#39;original&#39;:
        r_px = data_reference.r_px_original.to_list()
        c_px = data_reference.c_px_original.to_list()
    coords = np.array(list(zip(r_px,c_px)))
    position_idx = data_reference.index
    return coords, position_idx</code></pre>
</details>
</dd>
<dt id="pysmFISH.barcodes_analysis.extract_barcodes.dots_hoods"><code class="name flex">
<span>def <span class="ident">dots_hoods</span></span>(<span>coords, pxl)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def dots_hoods(coords,pxl):
    r_tl = coords[:,0]-pxl
    r_br = coords[:,0]+pxl
    c_tl = coords[:,1]-pxl
    c_tr = coords[:,1]+pxl
    r_tl = r_tl[:,np.newaxis]
    r_br = r_br[:,np.newaxis]
    c_tl = c_tl[:,np.newaxis]
    c_tr = c_tr[:,np.newaxis]
    chunks_coords = np.hstack((r_tl,r_br,c_tl,c_tr))
    chunks_coords = chunks_coords.astype(int)
    return chunks_coords</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pysmFISH.barcodes_analysis.extract_barcodes.run_extraction"><code class="name flex">
<span>def <span class="ident">run_extraction</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_extraction(self):
    # add check to make sure that the counts are there
    column_names = [&#39;r_px_original&#39;,&#39;c_px_original&#39;,&#39;dot_id&#39;,&#39;fov_num&#39;,&#39;round_num&#39;,&#39;dot_intensity_norm&#39;,
                    &#39;dot_intensity_not&#39;,&#39;selected_thr&#39; ,&#39;channel&#39;,&#39;r_shift&#39;,&#39;c_shift&#39;,&#39;r_px_registered&#39;,
                    &#39;c_px_registered&#39;,&#39;pixel_microns&#39;]
    column_names_output = column_names.copy()
    column_names_output.append(&#39;pxl_hood_size&#39;)
    column_names_output.append(&#39;raw_barcodes&#39;)
    self.barcodes_binary_images = {}
    if len(self.counts[&#39;r_px_registered&#39;]) &gt; 1:
        r_num = int(self.counts[&#39;r_px_registered&#39;].max())
        c_num = int(self.counts[&#39;c_px_registered&#39;].max())
        rounds_num = len(self.counts[&#39;round_num&#39;].unique())
        all_coords_image = np.zeros([rounds_num,r_num+1,c_num+1],dtype=np.int8)
        for round_num in np.arange(1,rounds_num+1):
            coords, ref_position_idx = self.combine_coords(self.counts, round_num, counts_type=&#39;registered&#39;)
            if np.any(np.isnan(coords)):
                stop = True
                break
            else:
                stop = False
                coords = coords.astype(np.int)
                all_coords_image[round_num-1,coords[:,0],coords[:,1]] = 1

        if stop:
            self.logger.error(f&#39;missing round {coords} no barcodes&#39;)
            self.output = pd.DataFrame(np.nan,index=[0],columns = column_names_output)
        else:
            self.output = pd.DataFrame(columns = column_names_output)
            self.output[&#39;pxl_hood_size&#39;] = np.nan
            self.output[&#39;raw_barcodes&#39;] = np.nan
            # self.raw_barcodes = []
            for round_num in np.arange(1,rounds_num+1):
                coords, ref_position_idx = self.combine_coords(self.counts, round_num, counts_type=&#39;registered&#39;)
                dot_ids = self.counts.loc[ref_position_idx,&#39;dot_id&#39;]
                dot_ids = dot_ids.reset_index()
                chunks_coords = self.dots_hoods(coords,self.pxl)
                for row in np.arange(coords.shape[0]):
                    chunk = chunks_coords[row,:]
                    dot_id = dot_ids.loc[row,&#39;dot_id&#39;]
                    selected_dot_coords = coords[row,:].astype(int)
                    barcode,selected_region = self.barcode_detection(all_coords_image,chunk,self.pxl)
                    # Add only the barcodes that are not all negatives (can happen because I am blanking the img)
                    if barcode.sum():
                        self.barcodes_binary_images[dot_id] = {}
                        self.barcodes_binary_images[dot_id][&#39;img&#39;] = selected_region
                        self.barcodes_binary_images[dot_id][&#39;raw_barcode&#39;] = barcode
                        # self.raw_barcodes.append(barcode)
                        # Blank the image
                        all_coords_image[:,selected_dot_coords[0],selected_dot_coords[1]] = 0
                        dot_data = self.counts[(self.counts[&#39;round_num&#39;] == round_num) &amp; (self.counts[&#39;r_px_registered&#39;] == selected_dot_coords[0]) &amp; (self.counts[&#39;c_px_registered&#39;] == selected_dot_coords[1])] 
                        barcode_st = &#39;&#39;
                        barcode_st = barcode_st.join([&#34;,&#34;.join(item) for item in barcode.astype(str)])
                        dot_data.insert(0,&#39;raw_barcodes&#39;,barcode_st)
                        dot_data.insert(0,&#39;pxl_hood_size&#39;,self.pxl)
                        self.output = pd.concat([self.output,dot_data],axis=0,ignore_index=True)
    
            # self.output[&#39;pxl_hood_size&#39;] = self.pxl
            # self.output[&#39;raw_barcodes&#39;] = self.raw_barcodes
    else:
        if self.save:
            self.output = pd.DataFrame(np.nan,index=[0],columns = column_names_output)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pysmFISH.barcodes_analysis.extract_barcodes_NN"><code class="flex name class">
<span>class <span class="ident">extract_barcodes_NN</span></span>
<span>(</span><span>counts, analysis_parameters: Dict, experiment_config: Dict, codebook_df, file_tags, status: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Class used to extract the barcodes from the registered
counts using nearest neighbour</p>
<h2 id="parameters">Parameters:</h2>
<p>counts: pandas.DataFrame
pandas file with the fov counts after
registration
analysis_parameters: dict
parameters for data processing
experiment_config: Dict
dictionary with the experimental data
codebook_df: pandas.DataFrame
pandas file with the codebook used to
deconvolve the barcode</p>
<p>NB: if there is a problem with the registration the barcode assigned
will be 0*barcode_length</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class extract_barcodes_NN():
    &#34;&#34;&#34;
    Class used to extract the barcodes from the registered
    counts using nearest neighbour

    Parameters:
    -----------
    counts: pandas.DataFrame
        pandas file with the fov counts after
        registration
    analysis_parameters: dict
        parameters for data processing
    experiment_config: Dict
        dictionary with the experimental data 
    codebook_df: pandas.DataFrame
        pandas file with the codebook used to
        deconvolve the barcode

    NB: if there is a problem with the registration the barcode assigned 
        will be 0*barcode_length
    
    &#34;&#34;&#34;

    def __init__(self, counts, analysis_parameters:Dict,experiment_config:Dict,codebook_df,file_tags,status:str):
        
        self.barcodes_extraction_resolution = analysis_parameters[&#39;BarcodesExtractionResolution&#39;]
        self.RegistrationMinMatchingBeads = analysis_parameters[&#39;RegistrationMinMatchingBeads&#39;]
        self.barcode_length = experiment_config[&#39;Barcode_length&#39;]
        self.counts = counts
        self.logger = selected_logger()
        self.codebook_df = codebook_df
        self.file_tags = file_tags
        self.status = status
        self.registration_errors = Registration_errors()



        
    @staticmethod
    def barcode_nn(counts_df, ref_round_number, barcodes_extraction_resolution):
        column_names = list(counts_df.columns.values)
        column_names = column_names.append(&#39;barcode_reference_dot_id&#39;)
        barcoded_df = pd.DataFrame(columns=column_names)

        reference_array = counts_df.loc[counts_df.round_num == ref_round_number, [&#39;r_px_registered&#39;,&#39;c_px_registered&#39;]].to_numpy()
        reference_round_df = counts_df.loc[counts_df.round_num == ref_round_number,:].reset_index(drop=True)
        # Step one (all dots not in round 1)
        coords_compare = counts_df.loc[counts_df.round_num != ref_round_number, [&#39;r_px_registered&#39;,&#39;c_px_registered&#39;]].to_numpy()
        compare_df = counts_df.loc[counts_df.round_num != ref_round_number,:].reset_index(drop=True)

        if (reference_array.shape[0] &gt;0) and (coords_compare.shape[0] &gt;0):
            # initialize network
            nn = NearestNeighbors(n_neighbors=1, metric=&#34;euclidean&#34;)
            nn.fit(reference_array)

            # Get the nn
            dists, indices = nn.kneighbors(coords_compare, return_distance=True)

            # select only the nn that are below barcodes_extraction_resolution distance
            idx_selected_coords_compare = np.where(dists &lt;= barcodes_extraction_resolution)[0]

            compare_selected_df = compare_df.loc[idx_selected_coords_compare,:]
            compare_selected_df[&#39;barcode_reference_dot_id&#39;] = np.nan

            # ref_idx = indices[idx_selected_coords_compare]
            # compare_selected_df.loc[compare_selected_df.index.isin(idx_selected_coords_compare),&#39;barcode_reference_dot_id&#39;] = reference_round_df.loc[ref_idx,&#39;dot_id&#39;].values[0]
            
            for idx in idx_selected_coords_compare:
                ref_idx = indices[idx]
                compare_selected_df.loc[idx,&#39;barcode_reference_dot_id&#39;] = reference_round_df.loc[ref_idx,&#39;dot_id&#39;].values[0]

            reference_round_df[&#39;barcode_reference_dot_id&#39;] = reference_round_df.dot_id

            barcoded_df = barcoded_df.append([compare_selected_df, reference_round_df], ignore_index=True)

            compare_df = compare_df.drop(compare_selected_df.index)
            compare_df = compare_df.reset_index(drop=True)
    
        return compare_df, barcoded_df

    @staticmethod
    def convert_str_codebook(codebook_df,column_name):
        codebook_df[column_name] = codebook_df[column_name].map(lambda x: np.frombuffer(x, np.int8))
        return codebook_df

    @staticmethod
    def make_codebook_array(codebook_df,column_name):
        codebook_array = np.zeros((len(codebook_df[column_name]),codebook_df[column_name][0].shape[0]))
        for idx, el in enumerate(codebook_df[column_name]):
            row = codebook_df[column_name][idx]
            row = row[np.newaxis,:]
            codebook_array[idx,:] = row
        return codebook_array


    def run_extraction(self):

        data_models = Output_models()
        registration_errors = Registration_errors()
        fov = self.file_tags[&#39;fov&#39;]
        channel = self.file_tags[&#39;channel&#39;]
        self.barcoded_fov_df = data_models.barcode_analysis_df
        self.barcoded_fov_df.attrs = self.counts.attrs

        if self.status == &#39;FAILED&#39;:
            error = self.counts[&#39;min_number_matching_dots_registration&#39;].values[0]
            round_num = self.counts[&#39;round_num&#39;].values[0]
            self.barcoded_fov_df = self.barcoded_fov_df.append({&#39;min_number_matching_dots_registration&#39;:error,
                                                           &#39;fov_num&#39;:int(fov),&#39;dot_channel&#39;:channel,&#39;round_num&#39;: round_num },ignore_index=True)
        elif self.status == &#39;SUCCESS&#39;:

            if (min(self.counts.loc[:,&#39;min_number_matching_dots_registration&#39;]) &lt; self.RegistrationMinMatchingBeads):
                round_num = self.counts[&#39;round_num&#39;].values[0]
                self.barcoded_fov_df = self.barcoded_fov_df.append({&#39;min_number_matching_dots_registration&#39;:registration_errors.registration_below_extraction_resolution, 
                                            &#39;fov_num&#39;:int(fov),&#39;dot_channel&#39;:channel,&#39;round_num&#39;: round_num},ignore_index=True)
                self.status = &#39;FAILED&#39;
            else:
                hd_2 = 2 / self.barcode_length
                hd_3 = 3 / self.barcode_length
                # barcode_length = len(self.counts[&#39;round_num&#39;].unique())
                rounds = np.arange(1,self.barcode_length+1)
                self.codebook_df = self.convert_str_codebook(self.codebook_df,&#39;Code&#39;)
                codebook_array = self.make_codebook_array(self.codebook_df,&#39;Code&#39;)
                nn_sklearn = NearestNeighbors(n_neighbors=1, metric=&#34;hamming&#34;)
                nn_sklearn.fit(codebook_array)

                # remove points with np.NAN
                # self.counts = self.counts.dropna()
                for round_num in rounds:
                    compare_df, barcoded_df = self.barcode_nn(self.counts, round_num, self.barcodes_extraction_resolution)
                    self.barcoded_fov_df = self.barcoded_fov_df.append(barcoded_df, ignore_index=True)
                    self.counts = compare_df

                self.counts[&#39;barcode_reference_dot_id&#39;] = self.counts.dot_id
                self.barcoded_fov_df = self.barcoded_fov_df.append(self.counts, ignore_index=True)
                self.barcoded_fov_df[&#39;barcodes_extraction_resolution&#39;] = self.barcodes_extraction_resolution
                self.grpd = self.barcoded_fov_df.groupby(&#39;barcode_reference_dot_id&#39;)
                # self.all_barcodes = {}
                # for name, group in self.grpd:
                #     rounds_num = group.round_num.values
                #     dot_ids = group.dot_id.values
                #     rounds_num = rounds_num.astype(int)
                #     barcode = np.zeros([self.barcode_length],dtype=np.int8)
                #     barcode[(rounds_num-1)] += 1

                #     dists_arr, index_arr = nn_sklearn.kneighbors(barcode.reshape(1, -1), return_distance=True)
                #     gene=self.codebook_df.loc[index_arr.reshape(index_arr.shape[0]),&#39;Gene&#39;].tolist()[0]
                #     self.barcoded_fov_df.loc[self.barcoded_fov_df.barcode_reference_dot_id == name,&#39;raw_barcodes&#39;] = barcode.tostring()
                #     self.barcoded_fov_df.loc[self.barcoded_fov_df.barcode_reference_dot_id == name,&#39;all_Hdistance_genes&#39;] = gene
                #     if dists_arr[0][0] == 0:
                #         self.barcoded_fov_df.loc[self.barcoded_fov_df.barcode_reference_dot_id == name,&#39;0Hdistance_genes&#39;] = gene
                #     elif dists_arr[0][0] &lt; hd_2:
                #         self.barcoded_fov_df.loc[self.barcoded_fov_df.barcode_reference_dot_id == name,&#39;below2Hdistance_genes&#39;] = gene
                #     elif dists_arr[0][0] &lt; hd_3:
                #         self.barcoded_fov_df.loc[self.barcoded_fov_df.barcode_reference_dot_id == name,&#39;below3Hdistance_genes&#39;] = gene


                barcode_reference_dot_id_list = []
                num_unique_dots = np.unique(self.barcoded_fov_df.loc[:,&#39;barcode_reference_dot_id&#39;]).shape[0]
                
                # There are no dots is the df
                if num_unique_dots &gt; 0:
                
                    all_barcodes = np.zeros([num_unique_dots,self.barcode_length],dtype=np.int8)
                    for idx, (name, group) in enumerate(self.grpd):
                        barcode_reference_dot_id_list.append(name)
                        barcode = np.zeros([self.barcode_length],dtype=np.int8)
                        rounds_num = group.round_num.values
                        rounds_num = rounds_num.astype(int)
                        barcode[(rounds_num-1)] += 1
                        all_barcodes[idx,:] = barcode

                    dists_arr, index_arr = nn_sklearn.kneighbors(all_barcodes, return_distance=True)
                    genes=self.codebook_df.loc[index_arr.reshape(index_arr.shape[0]),&#39;Gene&#39;].tolist()
                    for idx,name in enumerate(barcode_reference_dot_id_list):
                        barcode = all_barcodes[idx,:]
                        gene = genes[idx]
                        hd = dists_arr[idx][0]

                        cols = [&#39;raw_barcodes&#39;,&#39;all_Hdistance_genes&#39;,&#39;number_positive_bits&#39;,&#39;hamming_distance&#39;] # will add last column depending on hd
                        writing_data = [barcode.tostring(),gene,barcode.sum(),hd]
                        if hd == 0:
                            cols = cols + [&#39;zeroHdistance_genes&#39;]
                            writing_data = writing_data + [gene]

                        if hd &lt; hd_2:
                            cols = cols + [&#39;below2Hdistance_genes&#39;]
                            writing_data = writing_data + [gene]

                        if hd &lt; hd_3:
                            cols = cols + [&#39;below3Hdistance_genes&#39;]
                            writing_data = writing_data + [gene]

                        self.barcoded_fov_df.loc[self.barcoded_fov_df.barcode_reference_dot_id == name,cols] = writing_data


                        # self.barcoded_fov_df.loc[self.barcoded_fov_df.barcode_reference_dot_id == name,&#39;raw_barcodes&#39;] = barcode.tostring()
                        # self.barcoded_fov_df.loc[self.barcoded_fov_df.barcode_reference_dot_id == name,&#39;all_Hdistance_genes&#39;] = gene
                        # self.barcoded_fov_df.loc[self.barcoded_fov_df.barcode_reference_dot_id == name,&#39;number_positive_bits&#39;] = barcode.sum()
                        # self.barcoded_fov_df.loc[self.barcoded_fov_df.barcode_reference_dot_id == name,&#39;hamming_distance&#39;] = hd

                        # if hd == 0:
                        #     self.barcoded_fov_df.loc[self.barcoded_fov_df.barcode_reference_dot_id == name,&#39;0Hdistance_genes&#39;] = gene
                        # elif hd &lt; hd_2:
                        #     self.barcoded_fov_df.loc[self.barcoded_fov_df.barcode_reference_dot_id == name,&#39;below2Hdistance_genes&#39;] = gene
                        # elif hd &lt; hd_3:
                        #     self.barcoded_fov_df.loc[self.barcoded_fov_df.barcode_reference_dot_id == name,&#39;below3Hdistance_genes&#39;] = gene
   
        fname = self.file_tags[&#39;experiment_fpath&#39;] / &#39;tmp&#39; / &#39;registered_counts&#39; / (self.file_tags[&#39;experiment_name&#39;] + &#39;_&#39; + self.file_tags[&#39;channel&#39;] + &#39;_decoded_fov_&#39; + self.file_tags[&#39;fov&#39;] + &#39;.parquet&#39;)
        self.barcoded_fov_df.to_parquet(fname,index=False)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="pysmFISH.barcodes_analysis.extract_barcodes_NN.barcode_nn"><code class="name flex">
<span>def <span class="ident">barcode_nn</span></span>(<span>counts_df, ref_round_number, barcodes_extraction_resolution)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def barcode_nn(counts_df, ref_round_number, barcodes_extraction_resolution):
    column_names = list(counts_df.columns.values)
    column_names = column_names.append(&#39;barcode_reference_dot_id&#39;)
    barcoded_df = pd.DataFrame(columns=column_names)

    reference_array = counts_df.loc[counts_df.round_num == ref_round_number, [&#39;r_px_registered&#39;,&#39;c_px_registered&#39;]].to_numpy()
    reference_round_df = counts_df.loc[counts_df.round_num == ref_round_number,:].reset_index(drop=True)
    # Step one (all dots not in round 1)
    coords_compare = counts_df.loc[counts_df.round_num != ref_round_number, [&#39;r_px_registered&#39;,&#39;c_px_registered&#39;]].to_numpy()
    compare_df = counts_df.loc[counts_df.round_num != ref_round_number,:].reset_index(drop=True)

    if (reference_array.shape[0] &gt;0) and (coords_compare.shape[0] &gt;0):
        # initialize network
        nn = NearestNeighbors(n_neighbors=1, metric=&#34;euclidean&#34;)
        nn.fit(reference_array)

        # Get the nn
        dists, indices = nn.kneighbors(coords_compare, return_distance=True)

        # select only the nn that are below barcodes_extraction_resolution distance
        idx_selected_coords_compare = np.where(dists &lt;= barcodes_extraction_resolution)[0]

        compare_selected_df = compare_df.loc[idx_selected_coords_compare,:]
        compare_selected_df[&#39;barcode_reference_dot_id&#39;] = np.nan

        # ref_idx = indices[idx_selected_coords_compare]
        # compare_selected_df.loc[compare_selected_df.index.isin(idx_selected_coords_compare),&#39;barcode_reference_dot_id&#39;] = reference_round_df.loc[ref_idx,&#39;dot_id&#39;].values[0]
        
        for idx in idx_selected_coords_compare:
            ref_idx = indices[idx]
            compare_selected_df.loc[idx,&#39;barcode_reference_dot_id&#39;] = reference_round_df.loc[ref_idx,&#39;dot_id&#39;].values[0]

        reference_round_df[&#39;barcode_reference_dot_id&#39;] = reference_round_df.dot_id

        barcoded_df = barcoded_df.append([compare_selected_df, reference_round_df], ignore_index=True)

        compare_df = compare_df.drop(compare_selected_df.index)
        compare_df = compare_df.reset_index(drop=True)

    return compare_df, barcoded_df</code></pre>
</details>
</dd>
<dt id="pysmFISH.barcodes_analysis.extract_barcodes_NN.convert_str_codebook"><code class="name flex">
<span>def <span class="ident">convert_str_codebook</span></span>(<span>codebook_df, column_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def convert_str_codebook(codebook_df,column_name):
    codebook_df[column_name] = codebook_df[column_name].map(lambda x: np.frombuffer(x, np.int8))
    return codebook_df</code></pre>
</details>
</dd>
<dt id="pysmFISH.barcodes_analysis.extract_barcodes_NN.make_codebook_array"><code class="name flex">
<span>def <span class="ident">make_codebook_array</span></span>(<span>codebook_df, column_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def make_codebook_array(codebook_df,column_name):
    codebook_array = np.zeros((len(codebook_df[column_name]),codebook_df[column_name][0].shape[0]))
    for idx, el in enumerate(codebook_df[column_name]):
        row = codebook_df[column_name][idx]
        row = row[np.newaxis,:]
        codebook_array[idx,:] = row
    return codebook_array</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pysmFISH.barcodes_analysis.extract_barcodes_NN.run_extraction"><code class="name flex">
<span>def <span class="ident">run_extraction</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_extraction(self):

    data_models = Output_models()
    registration_errors = Registration_errors()
    fov = self.file_tags[&#39;fov&#39;]
    channel = self.file_tags[&#39;channel&#39;]
    self.barcoded_fov_df = data_models.barcode_analysis_df
    self.barcoded_fov_df.attrs = self.counts.attrs

    if self.status == &#39;FAILED&#39;:
        error = self.counts[&#39;min_number_matching_dots_registration&#39;].values[0]
        round_num = self.counts[&#39;round_num&#39;].values[0]
        self.barcoded_fov_df = self.barcoded_fov_df.append({&#39;min_number_matching_dots_registration&#39;:error,
                                                       &#39;fov_num&#39;:int(fov),&#39;dot_channel&#39;:channel,&#39;round_num&#39;: round_num },ignore_index=True)
    elif self.status == &#39;SUCCESS&#39;:

        if (min(self.counts.loc[:,&#39;min_number_matching_dots_registration&#39;]) &lt; self.RegistrationMinMatchingBeads):
            round_num = self.counts[&#39;round_num&#39;].values[0]
            self.barcoded_fov_df = self.barcoded_fov_df.append({&#39;min_number_matching_dots_registration&#39;:registration_errors.registration_below_extraction_resolution, 
                                        &#39;fov_num&#39;:int(fov),&#39;dot_channel&#39;:channel,&#39;round_num&#39;: round_num},ignore_index=True)
            self.status = &#39;FAILED&#39;
        else:
            hd_2 = 2 / self.barcode_length
            hd_3 = 3 / self.barcode_length
            # barcode_length = len(self.counts[&#39;round_num&#39;].unique())
            rounds = np.arange(1,self.barcode_length+1)
            self.codebook_df = self.convert_str_codebook(self.codebook_df,&#39;Code&#39;)
            codebook_array = self.make_codebook_array(self.codebook_df,&#39;Code&#39;)
            nn_sklearn = NearestNeighbors(n_neighbors=1, metric=&#34;hamming&#34;)
            nn_sklearn.fit(codebook_array)

            # remove points with np.NAN
            # self.counts = self.counts.dropna()
            for round_num in rounds:
                compare_df, barcoded_df = self.barcode_nn(self.counts, round_num, self.barcodes_extraction_resolution)
                self.barcoded_fov_df = self.barcoded_fov_df.append(barcoded_df, ignore_index=True)
                self.counts = compare_df

            self.counts[&#39;barcode_reference_dot_id&#39;] = self.counts.dot_id
            self.barcoded_fov_df = self.barcoded_fov_df.append(self.counts, ignore_index=True)
            self.barcoded_fov_df[&#39;barcodes_extraction_resolution&#39;] = self.barcodes_extraction_resolution
            self.grpd = self.barcoded_fov_df.groupby(&#39;barcode_reference_dot_id&#39;)
            # self.all_barcodes = {}
            # for name, group in self.grpd:
            #     rounds_num = group.round_num.values
            #     dot_ids = group.dot_id.values
            #     rounds_num = rounds_num.astype(int)
            #     barcode = np.zeros([self.barcode_length],dtype=np.int8)
            #     barcode[(rounds_num-1)] += 1

            #     dists_arr, index_arr = nn_sklearn.kneighbors(barcode.reshape(1, -1), return_distance=True)
            #     gene=self.codebook_df.loc[index_arr.reshape(index_arr.shape[0]),&#39;Gene&#39;].tolist()[0]
            #     self.barcoded_fov_df.loc[self.barcoded_fov_df.barcode_reference_dot_id == name,&#39;raw_barcodes&#39;] = barcode.tostring()
            #     self.barcoded_fov_df.loc[self.barcoded_fov_df.barcode_reference_dot_id == name,&#39;all_Hdistance_genes&#39;] = gene
            #     if dists_arr[0][0] == 0:
            #         self.barcoded_fov_df.loc[self.barcoded_fov_df.barcode_reference_dot_id == name,&#39;0Hdistance_genes&#39;] = gene
            #     elif dists_arr[0][0] &lt; hd_2:
            #         self.barcoded_fov_df.loc[self.barcoded_fov_df.barcode_reference_dot_id == name,&#39;below2Hdistance_genes&#39;] = gene
            #     elif dists_arr[0][0] &lt; hd_3:
            #         self.barcoded_fov_df.loc[self.barcoded_fov_df.barcode_reference_dot_id == name,&#39;below3Hdistance_genes&#39;] = gene


            barcode_reference_dot_id_list = []
            num_unique_dots = np.unique(self.barcoded_fov_df.loc[:,&#39;barcode_reference_dot_id&#39;]).shape[0]
            
            # There are no dots is the df
            if num_unique_dots &gt; 0:
            
                all_barcodes = np.zeros([num_unique_dots,self.barcode_length],dtype=np.int8)
                for idx, (name, group) in enumerate(self.grpd):
                    barcode_reference_dot_id_list.append(name)
                    barcode = np.zeros([self.barcode_length],dtype=np.int8)
                    rounds_num = group.round_num.values
                    rounds_num = rounds_num.astype(int)
                    barcode[(rounds_num-1)] += 1
                    all_barcodes[idx,:] = barcode

                dists_arr, index_arr = nn_sklearn.kneighbors(all_barcodes, return_distance=True)
                genes=self.codebook_df.loc[index_arr.reshape(index_arr.shape[0]),&#39;Gene&#39;].tolist()
                for idx,name in enumerate(barcode_reference_dot_id_list):
                    barcode = all_barcodes[idx,:]
                    gene = genes[idx]
                    hd = dists_arr[idx][0]

                    cols = [&#39;raw_barcodes&#39;,&#39;all_Hdistance_genes&#39;,&#39;number_positive_bits&#39;,&#39;hamming_distance&#39;] # will add last column depending on hd
                    writing_data = [barcode.tostring(),gene,barcode.sum(),hd]
                    if hd == 0:
                        cols = cols + [&#39;zeroHdistance_genes&#39;]
                        writing_data = writing_data + [gene]

                    if hd &lt; hd_2:
                        cols = cols + [&#39;below2Hdistance_genes&#39;]
                        writing_data = writing_data + [gene]

                    if hd &lt; hd_3:
                        cols = cols + [&#39;below3Hdistance_genes&#39;]
                        writing_data = writing_data + [gene]

                    self.barcoded_fov_df.loc[self.barcoded_fov_df.barcode_reference_dot_id == name,cols] = writing_data


                    # self.barcoded_fov_df.loc[self.barcoded_fov_df.barcode_reference_dot_id == name,&#39;raw_barcodes&#39;] = barcode.tostring()
                    # self.barcoded_fov_df.loc[self.barcoded_fov_df.barcode_reference_dot_id == name,&#39;all_Hdistance_genes&#39;] = gene
                    # self.barcoded_fov_df.loc[self.barcoded_fov_df.barcode_reference_dot_id == name,&#39;number_positive_bits&#39;] = barcode.sum()
                    # self.barcoded_fov_df.loc[self.barcoded_fov_df.barcode_reference_dot_id == name,&#39;hamming_distance&#39;] = hd

                    # if hd == 0:
                    #     self.barcoded_fov_df.loc[self.barcoded_fov_df.barcode_reference_dot_id == name,&#39;0Hdistance_genes&#39;] = gene
                    # elif hd &lt; hd_2:
                    #     self.barcoded_fov_df.loc[self.barcoded_fov_df.barcode_reference_dot_id == name,&#39;below2Hdistance_genes&#39;] = gene
                    # elif hd &lt; hd_3:
                    #     self.barcoded_fov_df.loc[self.barcoded_fov_df.barcode_reference_dot_id == name,&#39;below3Hdistance_genes&#39;] = gene

    fname = self.file_tags[&#39;experiment_fpath&#39;] / &#39;tmp&#39; / &#39;registered_counts&#39; / (self.file_tags[&#39;experiment_name&#39;] + &#39;_&#39; + self.file_tags[&#39;channel&#39;] + &#39;_decoded_fov_&#39; + self.file_tags[&#39;fov&#39;] + &#39;.parquet&#39;)
    self.barcoded_fov_df.to_parquet(fname,index=False)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pysmFISH.barcodes_analysis.extract_barcodes_NN_new"><code class="flex name class">
<span>class <span class="ident">extract_barcodes_NN_new</span></span>
<span>(</span><span>registered_counts, analysis_parameters: Dict, experiment_config: Dict, codebook_df)</span>
</code></dt>
<dd>
<div class="desc"><p>Class used to extract the barcodes from the registered
counts using nearest neighbour</p>
<h2 id="parameters">Parameters:</h2>
<p>counts: pandas.DataFrame
pandas file with the fov counts after
registration
analysis_parameters: dict
parameters for data processing
experiment_config: Dict
dictionary with the experimental data
codebook_df: pandas.DataFrame
pandas file with the codebook used to
deconvolve the barcode</p>
<p>NB: if there is a problem with the registration the barcode assigned
will be 0*barcode_length</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class extract_barcodes_NN_new():
    &#34;&#34;&#34;
    Class used to extract the barcodes from the registered
    counts using nearest neighbour

    Parameters:
    -----------
    counts: pandas.DataFrame
        pandas file with the fov counts after
        registration
    analysis_parameters: dict
        parameters for data processing
    experiment_config: Dict
        dictionary with the experimental data 
    codebook_df: pandas.DataFrame
        pandas file with the codebook used to
        deconvolve the barcode

    NB: if there is a problem with the registration the barcode assigned 
        will be 0*barcode_length
    
    &#34;&#34;&#34;

    def __init__(self, registered_counts, analysis_parameters:Dict,experiment_config:Dict,codebook_df):
        
        self.counts_df = registered_counts
        self.analysis_parameters = analysis_parameters
        self.experiment_config = experiment_config
        self.codebook_df = codebook_df
        
        self.logger = selected_logger()
        
        self.barcodes_extraction_resolution = analysis_parameters[&#39;BarcodesExtractionResolution&#39;]
        self.RegistrationMinMatchingBeads = analysis_parameters[&#39;RegistrationMinMatchingBeads&#39;]
        self.barcode_length = self.counts_df.loc[0][&#39;barcode_length&#39;]
        self.registration_errors = Registration_errors()

        self.stitching_channel = self.counts_df[&#39;stitching_channel&#39;].iloc[0]
        
    @staticmethod
    def convert_str_codebook(codebook_df,column_name):
        codebook_df[column_name] = codebook_df[column_name].map(lambda x: np.frombuffer(x, np.int8))
        return codebook_df

    @staticmethod
    def make_codebook_array(codebook_df,column_name):
        codebook_array = np.zeros((len(codebook_df[column_name]),codebook_df[column_name][0].shape[0]))
        for idx, el in enumerate(codebook_df[column_name]):
            row = codebook_df[column_name][idx]
            row = row[np.newaxis,:]
            codebook_array[idx,:] = row
        return codebook_array

    
    @staticmethod
    def barcode_nn(counts_df, ref_round_number, barcodes_extraction_resolution):
        column_names = list(counts_df.columns.values)
        column_names = column_names.append(&#39;barcode_reference_dot_id&#39;)
        barcoded_df = pd.DataFrame(columns=column_names)

        
        reference_array = counts_df.loc[counts_df.round_num == ref_round_number, [&#39;r_px_registered&#39;,&#39;c_px_registered&#39;]].to_numpy()
        reference_round_df = counts_df.loc[counts_df.round_num == ref_round_number,:].reset_index(drop=True)
    
        # Step one (all dots not in round 1)
        coords_compare = counts_df.loc[counts_df.round_num != ref_round_number, [&#39;r_px_registered&#39;,&#39;c_px_registered&#39;]].to_numpy()
        compare_df = counts_df.loc[counts_df.round_num != ref_round_number,:].reset_index(drop=True)
        
        if (reference_array.shape[0] &gt;0) and (coords_compare.shape[0] &gt;0):
            # initialize network
            nn = NearestNeighbors(n_neighbors=1, metric=&#34;euclidean&#34;)
            nn.fit(reference_array)

            # Get the nn
            dists, indices = nn.kneighbors(coords_compare, return_distance=True)

            # select only the nn that are below barcodes_extraction_resolution distance
            idx_selected_coords_compare = np.where(dists &lt;= barcodes_extraction_resolution)[0]
            compare_selected_df = compare_df.loc[idx_selected_coords_compare,:]
            compare_selected_df[&#39;barcode_reference_dot_id&#39;] = np.nan
            
            for k,v in groupby(idx_selected_coords_compare):
                if len(list(v)) &gt; 3:
                    print(&#34;key: &#39;{}&#39;--&gt; group: {}&#34;.format(k, len(list(v))))
            # ref_idx = indices[idx_selected_coords_compare].squeeze()
            # compare_selected_df.loc[compare_selected_df.index.isin(idx_selected_coords_compare),&#39;barcode_reference_dot_id&#39;] = reference_round_df.loc[ref_idx,&#39;dot_id&#39;].values[0]

            for idx in idx_selected_coords_compare:
                ref_idx = indices[idx]
                compare_selected_df.loc[idx,&#39;barcode_reference_dot_id&#39;] = reference_round_df.loc[ref_idx,&#39;dot_id&#39;].values[0]

            reference_round_df[&#39;barcode_reference_dot_id&#39;] = reference_round_df.dot_id

            barcoded_df = barcoded_df.append([compare_selected_df, reference_round_df], ignore_index=True)

            compare_df = compare_df.drop(compare_selected_df.index)
            compare_df = compare_df.reset_index(drop=True)
            
        return compare_df, barcoded_df

        
    def run_extraction(self):

        data_models = Output_models()
        registration_errors = Registration_errors()
        self.barcoded_spec = data_models.barcode_analysis_df

        if not self.counts_df[self.counts_df[&#39;dot_id&#39;].isnull()].empty:
            print(&#39;shitty FOV&#39;)
            self.all_combine_df = pd.concat([self.counts_df,self.barcoded_spec],axis=1)

        elif (min(self.counts_df[&#39;min_number_matching_dots_registration&#39;]) &lt; self.RegistrationMinMatchingBeads):

            self.counts_df[&#39;min_number_matching_dots_registration&#39;] = registration_errors.registration_below_extraction_resolution
            self.all_combine_df = pd.concat([self.counts_df,self.barcoded_spec],axis=1)

        else:
            self.counts_df = pd.concat([self.counts_df,self.barcoded_spec],axis=1)
            self.fish_counts = self.counts_df.loc[self.counts_df.channel != self.stitching_channel,:]
            
            hd_2 = 2 / self.barcode_length
            hd_3 = 3 / self.barcode_length
            rounds = np.arange(1,self.barcode_length+1)
            self.codebook_df = self.convert_str_codebook(self.codebook_df,&#39;Code&#39;)
            codebook_array = self.make_codebook_array(self.codebook_df,&#39;Code&#39;)
            nn_sklearn = NearestNeighbors(n_neighbors=1, metric=&#34;hamming&#34;)
            nn_sklearn.fit(codebook_array)
            
    
            self.index_df = pd.DataFrame(index=self.fish_counts.index,
                                        columns = [&#39;barcode_reference_dot_id&#39;,&#39;raw_barcodes&#39;])
            
            barcoded_df_list = []
            self.barcoded_fov_df = pd.DataFrame()
            for round_num in rounds:
                compare_df, barcoded_df = self.barcode_nn(self.fish_counts, round_num, self.barcodes_extraction_resolution)
                barcoded_df_list.append(barcoded_df)
                self.fish_counts = compare_df
            self.barcoded_fov_df = pd.concat(barcoded_df_list, ignore_index=True)
                
            self.fish_counts[&#39;barcode_reference_dot_id&#39;] = self.fish_counts.dot_id
            self.barcoded_fov_df = self.barcoded_fov_df.append(self.fish_counts, ignore_index=True)
            self.barcoded_fov_df[&#39;barcodes_extraction_resolution&#39;] = self.barcodes_extraction_resolution        
            self.grpd = self.barcoded_fov_df.groupby(&#39;barcode_reference_dot_id&#39;)

            barcode_reference_dot_id_list = []
            num_unique_dots = np.unique(self.barcoded_fov_df.loc[:,&#39;barcode_reference_dot_id&#39;]).shape[0]

            # There are no dots is the df
            if num_unique_dots &gt; 0:

                all_barcodes = np.zeros([num_unique_dots,self.barcode_length],dtype=np.int8)
                for idx, (name, group) in enumerate(self.grpd):
                    barcode_reference_dot_id_list.append(name)
                    barcode = np.zeros([self.barcode_length],dtype=np.int8)
                    rounds_num = group.round_num.values
                    rounds_num = rounds_num.astype(int)
                    barcode[(rounds_num-1)] += 1
                    all_barcodes[idx,:] = barcode

                dists_arr, index_arr = nn_sklearn.kneighbors(all_barcodes, return_distance=True)
                genes=self.codebook_df.loc[index_arr.reshape(index_arr.shape[0]),&#39;Gene&#39;].tolist()
                
                self.all_combine_df_list = []
                self.all_combine_df = pd.DataFrame()
                
                for idx, (name, group) in enumerate(self.grpd):
                    barcode = all_barcodes[idx,:]
                    gene = genes[idx]
                    hd = dists_arr[idx][0]

                    group_df = group
                    
                    group_df[&#39;raw_barcodes&#39;] = barcode.tostring()
                    group_df[&#39;all_Hdistance_genes&#39;] = gene
                    group_df[&#39;number_positive_bits&#39;] = barcode.sum()
                    group_df[&#39;hamming_distance&#39;] = hd
                    group_df[&#39;zeroHdistance_genes&#39;] = np.nan
                    group_df[&#39;below2Hdistance_genes&#39;] = np.nan
                    group_df[&#39;below3Hdistance_genes&#39;] = np.nan
                    
                    if hd == 0:
                        group_df[&#39;zeroHdistance_genes&#39;] = gene
                    if hd &lt; hd_2:
                        group_df[&#39;below2Hdistance_genes&#39;] = gene
                    if hd &lt; hd_3:
                        group_df[&#39;below3Hdistance_genes&#39;] = gene
                    
                    self.all_combine_df_list.append(group_df)
                
                # self.all_combine_df = pd.concat(self.all_combine_df_list, axis=0,copy=False) 
                chunk_size = 500
                self.all_combine_df = merge_with_concat((merge_with_concat(dfs) for dfs in chunk_dfs(self.all_combine_df_list, chunk_size)))
  
            else:
                self.all_combine_df = self.fish_counts   # add the missing column and control error for stitching</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="pysmFISH.barcodes_analysis.extract_barcodes_NN_new.barcode_nn"><code class="name flex">
<span>def <span class="ident">barcode_nn</span></span>(<span>counts_df, ref_round_number, barcodes_extraction_resolution)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def barcode_nn(counts_df, ref_round_number, barcodes_extraction_resolution):
    column_names = list(counts_df.columns.values)
    column_names = column_names.append(&#39;barcode_reference_dot_id&#39;)
    barcoded_df = pd.DataFrame(columns=column_names)

    
    reference_array = counts_df.loc[counts_df.round_num == ref_round_number, [&#39;r_px_registered&#39;,&#39;c_px_registered&#39;]].to_numpy()
    reference_round_df = counts_df.loc[counts_df.round_num == ref_round_number,:].reset_index(drop=True)

    # Step one (all dots not in round 1)
    coords_compare = counts_df.loc[counts_df.round_num != ref_round_number, [&#39;r_px_registered&#39;,&#39;c_px_registered&#39;]].to_numpy()
    compare_df = counts_df.loc[counts_df.round_num != ref_round_number,:].reset_index(drop=True)
    
    if (reference_array.shape[0] &gt;0) and (coords_compare.shape[0] &gt;0):
        # initialize network
        nn = NearestNeighbors(n_neighbors=1, metric=&#34;euclidean&#34;)
        nn.fit(reference_array)

        # Get the nn
        dists, indices = nn.kneighbors(coords_compare, return_distance=True)

        # select only the nn that are below barcodes_extraction_resolution distance
        idx_selected_coords_compare = np.where(dists &lt;= barcodes_extraction_resolution)[0]
        compare_selected_df = compare_df.loc[idx_selected_coords_compare,:]
        compare_selected_df[&#39;barcode_reference_dot_id&#39;] = np.nan
        
        for k,v in groupby(idx_selected_coords_compare):
            if len(list(v)) &gt; 3:
                print(&#34;key: &#39;{}&#39;--&gt; group: {}&#34;.format(k, len(list(v))))
        # ref_idx = indices[idx_selected_coords_compare].squeeze()
        # compare_selected_df.loc[compare_selected_df.index.isin(idx_selected_coords_compare),&#39;barcode_reference_dot_id&#39;] = reference_round_df.loc[ref_idx,&#39;dot_id&#39;].values[0]

        for idx in idx_selected_coords_compare:
            ref_idx = indices[idx]
            compare_selected_df.loc[idx,&#39;barcode_reference_dot_id&#39;] = reference_round_df.loc[ref_idx,&#39;dot_id&#39;].values[0]

        reference_round_df[&#39;barcode_reference_dot_id&#39;] = reference_round_df.dot_id

        barcoded_df = barcoded_df.append([compare_selected_df, reference_round_df], ignore_index=True)

        compare_df = compare_df.drop(compare_selected_df.index)
        compare_df = compare_df.reset_index(drop=True)
        
    return compare_df, barcoded_df</code></pre>
</details>
</dd>
<dt id="pysmFISH.barcodes_analysis.extract_barcodes_NN_new.convert_str_codebook"><code class="name flex">
<span>def <span class="ident">convert_str_codebook</span></span>(<span>codebook_df, column_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def convert_str_codebook(codebook_df,column_name):
    codebook_df[column_name] = codebook_df[column_name].map(lambda x: np.frombuffer(x, np.int8))
    return codebook_df</code></pre>
</details>
</dd>
<dt id="pysmFISH.barcodes_analysis.extract_barcodes_NN_new.make_codebook_array"><code class="name flex">
<span>def <span class="ident">make_codebook_array</span></span>(<span>codebook_df, column_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def make_codebook_array(codebook_df,column_name):
    codebook_array = np.zeros((len(codebook_df[column_name]),codebook_df[column_name][0].shape[0]))
    for idx, el in enumerate(codebook_df[column_name]):
        row = codebook_df[column_name][idx]
        row = row[np.newaxis,:]
        codebook_array[idx,:] = row
    return codebook_array</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pysmFISH.barcodes_analysis.extract_barcodes_NN_new.run_extraction"><code class="name flex">
<span>def <span class="ident">run_extraction</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_extraction(self):

    data_models = Output_models()
    registration_errors = Registration_errors()
    self.barcoded_spec = data_models.barcode_analysis_df

    if not self.counts_df[self.counts_df[&#39;dot_id&#39;].isnull()].empty:
        print(&#39;shitty FOV&#39;)
        self.all_combine_df = pd.concat([self.counts_df,self.barcoded_spec],axis=1)

    elif (min(self.counts_df[&#39;min_number_matching_dots_registration&#39;]) &lt; self.RegistrationMinMatchingBeads):

        self.counts_df[&#39;min_number_matching_dots_registration&#39;] = registration_errors.registration_below_extraction_resolution
        self.all_combine_df = pd.concat([self.counts_df,self.barcoded_spec],axis=1)

    else:
        self.counts_df = pd.concat([self.counts_df,self.barcoded_spec],axis=1)
        self.fish_counts = self.counts_df.loc[self.counts_df.channel != self.stitching_channel,:]
        
        hd_2 = 2 / self.barcode_length
        hd_3 = 3 / self.barcode_length
        rounds = np.arange(1,self.barcode_length+1)
        self.codebook_df = self.convert_str_codebook(self.codebook_df,&#39;Code&#39;)
        codebook_array = self.make_codebook_array(self.codebook_df,&#39;Code&#39;)
        nn_sklearn = NearestNeighbors(n_neighbors=1, metric=&#34;hamming&#34;)
        nn_sklearn.fit(codebook_array)
        

        self.index_df = pd.DataFrame(index=self.fish_counts.index,
                                    columns = [&#39;barcode_reference_dot_id&#39;,&#39;raw_barcodes&#39;])
        
        barcoded_df_list = []
        self.barcoded_fov_df = pd.DataFrame()
        for round_num in rounds:
            compare_df, barcoded_df = self.barcode_nn(self.fish_counts, round_num, self.barcodes_extraction_resolution)
            barcoded_df_list.append(barcoded_df)
            self.fish_counts = compare_df
        self.barcoded_fov_df = pd.concat(barcoded_df_list, ignore_index=True)
            
        self.fish_counts[&#39;barcode_reference_dot_id&#39;] = self.fish_counts.dot_id
        self.barcoded_fov_df = self.barcoded_fov_df.append(self.fish_counts, ignore_index=True)
        self.barcoded_fov_df[&#39;barcodes_extraction_resolution&#39;] = self.barcodes_extraction_resolution        
        self.grpd = self.barcoded_fov_df.groupby(&#39;barcode_reference_dot_id&#39;)

        barcode_reference_dot_id_list = []
        num_unique_dots = np.unique(self.barcoded_fov_df.loc[:,&#39;barcode_reference_dot_id&#39;]).shape[0]

        # There are no dots is the df
        if num_unique_dots &gt; 0:

            all_barcodes = np.zeros([num_unique_dots,self.barcode_length],dtype=np.int8)
            for idx, (name, group) in enumerate(self.grpd):
                barcode_reference_dot_id_list.append(name)
                barcode = np.zeros([self.barcode_length],dtype=np.int8)
                rounds_num = group.round_num.values
                rounds_num = rounds_num.astype(int)
                barcode[(rounds_num-1)] += 1
                all_barcodes[idx,:] = barcode

            dists_arr, index_arr = nn_sklearn.kneighbors(all_barcodes, return_distance=True)
            genes=self.codebook_df.loc[index_arr.reshape(index_arr.shape[0]),&#39;Gene&#39;].tolist()
            
            self.all_combine_df_list = []
            self.all_combine_df = pd.DataFrame()
            
            for idx, (name, group) in enumerate(self.grpd):
                barcode = all_barcodes[idx,:]
                gene = genes[idx]
                hd = dists_arr[idx][0]

                group_df = group
                
                group_df[&#39;raw_barcodes&#39;] = barcode.tostring()
                group_df[&#39;all_Hdistance_genes&#39;] = gene
                group_df[&#39;number_positive_bits&#39;] = barcode.sum()
                group_df[&#39;hamming_distance&#39;] = hd
                group_df[&#39;zeroHdistance_genes&#39;] = np.nan
                group_df[&#39;below2Hdistance_genes&#39;] = np.nan
                group_df[&#39;below3Hdistance_genes&#39;] = np.nan
                
                if hd == 0:
                    group_df[&#39;zeroHdistance_genes&#39;] = gene
                if hd &lt; hd_2:
                    group_df[&#39;below2Hdistance_genes&#39;] = gene
                if hd &lt; hd_3:
                    group_df[&#39;below3Hdistance_genes&#39;] = gene
                
                self.all_combine_df_list.append(group_df)
            
            # self.all_combine_df = pd.concat(self.all_combine_df_list, axis=0,copy=False) 
            chunk_size = 500
            self.all_combine_df = merge_with_concat((merge_with_concat(dfs) for dfs in chunk_dfs(self.all_combine_df_list, chunk_size)))

        else:
            self.all_combine_df = self.fish_counts   # add the missing column and control error for stitching</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pysmFISH.barcodes_analysis.extract_barcodes_NN_test"><code class="flex name class">
<span>class <span class="ident">extract_barcodes_NN_test</span></span>
<span>(</span><span>fov, channel, counts, analysis_parameters: Dict, experiment_config: Dict, codebook_df, status: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Class used to extract the barcodes from the registered
counts using nearest neighbour</p>
<h2 id="parameters">Parameters:</h2>
<p>counts: pandas.DataFrame
pandas file with the fov counts after
registration
analysis_parameters: dict
parameters for data processing
experiment_config: Dict
dictionary with the experimental data
codebook_df: pandas.DataFrame
pandas file with the codebook used to
deconvolve the barcode</p>
<p>NB: if there is a problem with the registration the barcode assigned
will be 0*barcode_length</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class extract_barcodes_NN_test():
    &#34;&#34;&#34;
    Class used to extract the barcodes from the registered
    counts using nearest neighbour

    Parameters:
    -----------
    counts: pandas.DataFrame
        pandas file with the fov counts after
        registration
    analysis_parameters: dict
        parameters for data processing
    experiment_config: Dict
        dictionary with the experimental data 
    codebook_df: pandas.DataFrame
        pandas file with the codebook used to
        deconvolve the barcode

    NB: if there is a problem with the registration the barcode assigned 
        will be 0*barcode_length
    
    &#34;&#34;&#34;

    def __init__(self, fov, channel, counts, analysis_parameters:Dict,experiment_config:Dict,codebook_df,status:str):
        
        self.barcodes_extraction_resolution = analysis_parameters[&#39;BarcodesExtractionResolution&#39;]
        self.RegistrationMinMatchingBeads = analysis_parameters[&#39;RegistrationMinMatchingBeads&#39;]
        self.barcode_length = experiment_config[&#39;Barcode_length&#39;]
        self.fov = fov
        self.channel = channel
        self.counts = counts
        self.logger = selected_logger()
        self.codebook_df = codebook_df
        self.status = status
        self.registration_errors = Registration_errors()



        
    @staticmethod
    def barcode_nn(counts_df, ref_round_number, barcodes_extraction_resolution):
        column_names = list(counts_df.columns.values)
        column_names = column_names.append(&#39;barcode_reference_dot_id&#39;)
        barcoded_df = pd.DataFrame(columns=column_names)

        reference_array = counts_df.loc[counts_df.round_num == ref_round_number, [&#39;r_px_registered&#39;,&#39;c_px_registered&#39;]].to_numpy()
        reference_round_df = counts_df.loc[counts_df.round_num == ref_round_number,:].reset_index(drop=True)
        # Step one (all dots not in round 1)
        coords_compare = counts_df.loc[counts_df.round_num != ref_round_number, [&#39;r_px_registered&#39;,&#39;c_px_registered&#39;]].to_numpy()
        compare_df = counts_df.loc[counts_df.round_num != ref_round_number,:].reset_index(drop=True)

        if (reference_array.shape[0] &gt;0) and (coords_compare.shape[0] &gt;0):
            # initialize network
            nn = NearestNeighbors(n_neighbors=1, metric=&#34;euclidean&#34;)
            nn.fit(reference_array)

            # Get the nn
            dists, indices = nn.kneighbors(coords_compare, return_distance=True)

            # select only the nn that are below barcodes_extraction_resolution distance
            idx_selected_coords_compare = np.where(dists &lt;= barcodes_extraction_resolution)[0]

            compare_selected_df = compare_df.loc[idx_selected_coords_compare,:]
            compare_selected_df[&#39;barcode_reference_dot_id&#39;] = np.nan

            # ref_idx = indices[idx_selected_coords_compare]
            # compare_selected_df.loc[compare_selected_df.index.isin(idx_selected_coords_compare),&#39;barcode_reference_dot_id&#39;] = reference_round_df.loc[ref_idx,&#39;dot_id&#39;].values[0]
            
            for idx in idx_selected_coords_compare:
                ref_idx = indices[idx]
                compare_selected_df.loc[idx,&#39;barcode_reference_dot_id&#39;] = reference_round_df.loc[ref_idx,&#39;dot_id&#39;].values[0]

            reference_round_df[&#39;barcode_reference_dot_id&#39;] = reference_round_df.dot_id

            barcoded_df = barcoded_df.append([compare_selected_df, reference_round_df], ignore_index=True)

            compare_df = compare_df.drop(compare_selected_df.index)
            compare_df = compare_df.reset_index(drop=True)
    
        return compare_df, barcoded_df

    @staticmethod
    def convert_str_codebook(codebook_df,column_name):
        codebook_df[column_name] = codebook_df[column_name].map(lambda x: np.frombuffer(x, np.int8))
        return codebook_df

    @staticmethod
    def make_codebook_array(codebook_df,column_name):
        codebook_array = np.zeros((len(codebook_df[column_name]),codebook_df[column_name][0].shape[0]))
        for idx, el in enumerate(codebook_df[column_name]):
            row = codebook_df[column_name][idx]
            row = row[np.newaxis,:]
            codebook_array[idx,:] = row
        return codebook_array



    def run_extraction(self):

        data_models = Output_models()
        registration_errors = Registration_errors()
        self.barcoded_fov_df = data_models.barcode_analysis_df
        self.barcoded_fov_df.attrs = self.counts.attrs

        if self.status == &#39;FAILED&#39;:
            error = self.counts[&#39;min_number_matching_dots_registration&#39;].values[0]
            round_num = self.counts[&#39;round_num&#39;].values[0]
            self.barcoded_fov_df = self.barcoded_fov_df.append({&#39;min_number_matching_dots_registration&#39;:error,
                                                           &#39;fov_num&#39;:int(self.fov),&#39;dot_channel&#39;:self.channel,&#39;round_num&#39;: round_num },ignore_index=True)
        elif self.status == &#39;SUCCESS&#39;:

            if (min(self.counts.loc[:,&#39;min_number_matching_dots_registration&#39;]) &lt; self.RegistrationMinMatchingBeads):
                round_num = self.counts[&#39;round_num&#39;].values[0]
                self.barcoded_fov_df = self.barcoded_fov_df.append({&#39;min_number_matching_dots_registration&#39;:registration_errors.registration_below_extraction_resolution, 
                                            &#39;fov_num&#39;:int(self.fov),&#39;dot_channel&#39;:self.channel,&#39;round_num&#39;: round_num},ignore_index=True)
                self.status = &#39;FAILED&#39;
            else:
                hd_2 = 2 / self.barcode_length
                hd_3 = 3 / self.barcode_length
                # barcode_length = len(self.counts[&#39;round_num&#39;].unique())
                rounds = np.arange(1,self.barcode_length+1)
                self.codebook_df = self.convert_str_codebook(self.codebook_df,&#39;Code&#39;)
                codebook_array = self.make_codebook_array(self.codebook_df,&#39;Code&#39;)
                nn_sklearn = NearestNeighbors(n_neighbors=1, metric=&#34;hamming&#34;)
                nn_sklearn.fit(codebook_array)

                # remove points with np.NAN
                # self.counts = self.counts.dropna()
                for round_num in rounds:
                    compare_df, barcoded_df = self.barcode_nn(self.counts, round_num, self.barcodes_extraction_resolution)
                    self.barcoded_fov_df = self.barcoded_fov_df.append(barcoded_df, ignore_index=True)
                    self.counts = compare_df

                self.counts[&#39;barcode_reference_dot_id&#39;] = self.counts.dot_id
                self.barcoded_fov_df = self.barcoded_fov_df.append(self.counts, ignore_index=True)
                self.barcoded_fov_df[&#39;barcodes_extraction_resolution&#39;] = self.barcodes_extraction_resolution
                self.grpd = self.barcoded_fov_df.groupby(&#39;barcode_reference_dot_id&#39;)

                barcode_reference_dot_id_list = []
                num_unique_dots = np.unique(self.barcoded_fov_df.loc[:,&#39;barcode_reference_dot_id&#39;]).shape[0]
                
                # There are no dots is the df
                if num_unique_dots &gt; 0:
                
                    all_barcodes = np.zeros([num_unique_dots,self.barcode_length],dtype=np.int8)
                    for idx, (name, group) in enumerate(self.grpd):
                        barcode_reference_dot_id_list.append(name)
                        barcode = np.zeros([self.barcode_length],dtype=np.int8)
                        rounds_num = group.round_num.values
                        rounds_num = rounds_num.astype(int)
                        barcode[(rounds_num-1)] += 1
                        all_barcodes[idx,:] = barcode

                    dists_arr, index_arr = nn_sklearn.kneighbors(all_barcodes, return_distance=True)
                    genes=self.codebook_df.loc[index_arr.reshape(index_arr.shape[0]),&#39;Gene&#39;].tolist()
                    for idx,name in enumerate(barcode_reference_dot_id_list):
                        barcode = all_barcodes[idx,:]
                        gene = genes[idx]
                        hd = dists_arr[idx][0]

                        cols = [&#39;raw_barcodes&#39;,&#39;all_Hdistance_genes&#39;,&#39;number_positive_bits&#39;,&#39;hamming_distance&#39;] # will add last column depending on hd
                        writing_data = [barcode.tostring(),gene,barcode.sum(),hd]
                        if hd == 0:
                            cols = cols + [&#39;zeroHdistance_genes&#39;]
                            writing_data = writing_data + [gene]

                        if hd &lt; hd_2:
                            cols = cols + [&#39;below2Hdistance_genes&#39;]
                            writing_data = writing_data + [gene]

                        if hd &lt; hd_3:
                            cols = cols + [&#39;below3Hdistance_genes&#39;]
                            writing_data = writing_data + [gene]

                        self.barcoded_fov_df.loc[self.barcoded_fov_df.barcode_reference_dot_id == name,cols] = writing_data</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="pysmFISH.barcodes_analysis.extract_barcodes_NN_test.barcode_nn"><code class="name flex">
<span>def <span class="ident">barcode_nn</span></span>(<span>counts_df, ref_round_number, barcodes_extraction_resolution)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def barcode_nn(counts_df, ref_round_number, barcodes_extraction_resolution):
    column_names = list(counts_df.columns.values)
    column_names = column_names.append(&#39;barcode_reference_dot_id&#39;)
    barcoded_df = pd.DataFrame(columns=column_names)

    reference_array = counts_df.loc[counts_df.round_num == ref_round_number, [&#39;r_px_registered&#39;,&#39;c_px_registered&#39;]].to_numpy()
    reference_round_df = counts_df.loc[counts_df.round_num == ref_round_number,:].reset_index(drop=True)
    # Step one (all dots not in round 1)
    coords_compare = counts_df.loc[counts_df.round_num != ref_round_number, [&#39;r_px_registered&#39;,&#39;c_px_registered&#39;]].to_numpy()
    compare_df = counts_df.loc[counts_df.round_num != ref_round_number,:].reset_index(drop=True)

    if (reference_array.shape[0] &gt;0) and (coords_compare.shape[0] &gt;0):
        # initialize network
        nn = NearestNeighbors(n_neighbors=1, metric=&#34;euclidean&#34;)
        nn.fit(reference_array)

        # Get the nn
        dists, indices = nn.kneighbors(coords_compare, return_distance=True)

        # select only the nn that are below barcodes_extraction_resolution distance
        idx_selected_coords_compare = np.where(dists &lt;= barcodes_extraction_resolution)[0]

        compare_selected_df = compare_df.loc[idx_selected_coords_compare,:]
        compare_selected_df[&#39;barcode_reference_dot_id&#39;] = np.nan

        # ref_idx = indices[idx_selected_coords_compare]
        # compare_selected_df.loc[compare_selected_df.index.isin(idx_selected_coords_compare),&#39;barcode_reference_dot_id&#39;] = reference_round_df.loc[ref_idx,&#39;dot_id&#39;].values[0]
        
        for idx in idx_selected_coords_compare:
            ref_idx = indices[idx]
            compare_selected_df.loc[idx,&#39;barcode_reference_dot_id&#39;] = reference_round_df.loc[ref_idx,&#39;dot_id&#39;].values[0]

        reference_round_df[&#39;barcode_reference_dot_id&#39;] = reference_round_df.dot_id

        barcoded_df = barcoded_df.append([compare_selected_df, reference_round_df], ignore_index=True)

        compare_df = compare_df.drop(compare_selected_df.index)
        compare_df = compare_df.reset_index(drop=True)

    return compare_df, barcoded_df</code></pre>
</details>
</dd>
<dt id="pysmFISH.barcodes_analysis.extract_barcodes_NN_test.convert_str_codebook"><code class="name flex">
<span>def <span class="ident">convert_str_codebook</span></span>(<span>codebook_df, column_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def convert_str_codebook(codebook_df,column_name):
    codebook_df[column_name] = codebook_df[column_name].map(lambda x: np.frombuffer(x, np.int8))
    return codebook_df</code></pre>
</details>
</dd>
<dt id="pysmFISH.barcodes_analysis.extract_barcodes_NN_test.make_codebook_array"><code class="name flex">
<span>def <span class="ident">make_codebook_array</span></span>(<span>codebook_df, column_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def make_codebook_array(codebook_df,column_name):
    codebook_array = np.zeros((len(codebook_df[column_name]),codebook_df[column_name][0].shape[0]))
    for idx, el in enumerate(codebook_df[column_name]):
        row = codebook_df[column_name][idx]
        row = row[np.newaxis,:]
        codebook_array[idx,:] = row
    return codebook_array</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pysmFISH.barcodes_analysis.extract_barcodes_NN_test.run_extraction"><code class="name flex">
<span>def <span class="ident">run_extraction</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_extraction(self):

    data_models = Output_models()
    registration_errors = Registration_errors()
    self.barcoded_fov_df = data_models.barcode_analysis_df
    self.barcoded_fov_df.attrs = self.counts.attrs

    if self.status == &#39;FAILED&#39;:
        error = self.counts[&#39;min_number_matching_dots_registration&#39;].values[0]
        round_num = self.counts[&#39;round_num&#39;].values[0]
        self.barcoded_fov_df = self.barcoded_fov_df.append({&#39;min_number_matching_dots_registration&#39;:error,
                                                       &#39;fov_num&#39;:int(self.fov),&#39;dot_channel&#39;:self.channel,&#39;round_num&#39;: round_num },ignore_index=True)
    elif self.status == &#39;SUCCESS&#39;:

        if (min(self.counts.loc[:,&#39;min_number_matching_dots_registration&#39;]) &lt; self.RegistrationMinMatchingBeads):
            round_num = self.counts[&#39;round_num&#39;].values[0]
            self.barcoded_fov_df = self.barcoded_fov_df.append({&#39;min_number_matching_dots_registration&#39;:registration_errors.registration_below_extraction_resolution, 
                                        &#39;fov_num&#39;:int(self.fov),&#39;dot_channel&#39;:self.channel,&#39;round_num&#39;: round_num},ignore_index=True)
            self.status = &#39;FAILED&#39;
        else:
            hd_2 = 2 / self.barcode_length
            hd_3 = 3 / self.barcode_length
            # barcode_length = len(self.counts[&#39;round_num&#39;].unique())
            rounds = np.arange(1,self.barcode_length+1)
            self.codebook_df = self.convert_str_codebook(self.codebook_df,&#39;Code&#39;)
            codebook_array = self.make_codebook_array(self.codebook_df,&#39;Code&#39;)
            nn_sklearn = NearestNeighbors(n_neighbors=1, metric=&#34;hamming&#34;)
            nn_sklearn.fit(codebook_array)

            # remove points with np.NAN
            # self.counts = self.counts.dropna()
            for round_num in rounds:
                compare_df, barcoded_df = self.barcode_nn(self.counts, round_num, self.barcodes_extraction_resolution)
                self.barcoded_fov_df = self.barcoded_fov_df.append(barcoded_df, ignore_index=True)
                self.counts = compare_df

            self.counts[&#39;barcode_reference_dot_id&#39;] = self.counts.dot_id
            self.barcoded_fov_df = self.barcoded_fov_df.append(self.counts, ignore_index=True)
            self.barcoded_fov_df[&#39;barcodes_extraction_resolution&#39;] = self.barcodes_extraction_resolution
            self.grpd = self.barcoded_fov_df.groupby(&#39;barcode_reference_dot_id&#39;)

            barcode_reference_dot_id_list = []
            num_unique_dots = np.unique(self.barcoded_fov_df.loc[:,&#39;barcode_reference_dot_id&#39;]).shape[0]
            
            # There are no dots is the df
            if num_unique_dots &gt; 0:
            
                all_barcodes = np.zeros([num_unique_dots,self.barcode_length],dtype=np.int8)
                for idx, (name, group) in enumerate(self.grpd):
                    barcode_reference_dot_id_list.append(name)
                    barcode = np.zeros([self.barcode_length],dtype=np.int8)
                    rounds_num = group.round_num.values
                    rounds_num = rounds_num.astype(int)
                    barcode[(rounds_num-1)] += 1
                    all_barcodes[idx,:] = barcode

                dists_arr, index_arr = nn_sklearn.kneighbors(all_barcodes, return_distance=True)
                genes=self.codebook_df.loc[index_arr.reshape(index_arr.shape[0]),&#39;Gene&#39;].tolist()
                for idx,name in enumerate(barcode_reference_dot_id_list):
                    barcode = all_barcodes[idx,:]
                    gene = genes[idx]
                    hd = dists_arr[idx][0]

                    cols = [&#39;raw_barcodes&#39;,&#39;all_Hdistance_genes&#39;,&#39;number_positive_bits&#39;,&#39;hamming_distance&#39;] # will add last column depending on hd
                    writing_data = [barcode.tostring(),gene,barcode.sum(),hd]
                    if hd == 0:
                        cols = cols + [&#39;zeroHdistance_genes&#39;]
                        writing_data = writing_data + [gene]

                    if hd &lt; hd_2:
                        cols = cols + [&#39;below2Hdistance_genes&#39;]
                        writing_data = writing_data + [gene]

                    if hd &lt; hd_3:
                        cols = cols + [&#39;below3Hdistance_genes&#39;]
                        writing_data = writing_data + [gene]

                    self.barcoded_fov_df.loc[self.barcoded_fov_df.barcode_reference_dot_id == name,cols] = writing_data</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pysmFISH.barcodes_analysis.simplify_barcodes_reference"><code class="flex name class">
<span>class <span class="ident">simplify_barcodes_reference</span></span>
<span>(</span><span>barcode_fpath: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Utility Class use to convert excels files with codebook info
in smaller size pandas dataframe/parquet files to pass to dask
workers during the processing. This utility function must be
run before running the experiment analysis. The pipeline
require the output of this function.</p>
<p>Class initialization</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>barcode_fpath</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the xlsx file with the codebook</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class simplify_barcodes_reference():
    &#34;&#34;&#34;Utility Class use to convert excels files with codebook info
    in smaller size pandas dataframe/parquet files to pass to dask
    workers during the processing. This utility function must be
    run before running the experiment analysis. The pipeline
    require the output of this function.
    &#34;&#34;&#34;
    
    def __init__(self, barcode_fpath: str):
        &#34;&#34;&#34;Class initialization

        Args:
            barcode_fpath (str): Path to the xlsx file with the codebook
        &#34;&#34;&#34;
        
        self.barcode_fpath = Path(barcode_fpath)
        self.barcode_fname = self.barcode_fpath.stem

    @staticmethod
    def format_codeword(codeword: str):
        &#34;&#34;&#34;[summary]

        Args:
            codeword (str): codeword representing a gene

        Returns:
            byte: codeword converted in byte representation
        &#34;&#34;&#34;
        str_num = codeword.split(&#39;[&#39;)[-1].split(&#39;]&#39;)[0]
        converted_codeword = np.array([int(el) for el in list(str_num)]).astype(np.int8)
        converted_codeword = converted_codeword.tobytes()
        return converted_codeword

    def convert_codebook(self):
        used_gene_codebook_df = pd.read_excel(self.barcode_fpath)
        # used_gene_codebook_df = pd.read_parquet(self.barcode_fpath)
        self.codebook_df = used_gene_codebook_df.loc[:,[&#39;Barcode&#39;,&#39;Gene&#39;]]
        self.codebook_df.rename(columns = {&#39;Barcode&#39;:&#39;Code&#39;}, inplace = True)
        self.codebook_df.Code = self.codebook_df.Code.apply(lambda x: self.format_codeword(x))
        self.codebook_df.to_parquet(self.barcode_fpath.parent / (self.barcode_fname + &#39;.parquet&#39;))</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="pysmFISH.barcodes_analysis.simplify_barcodes_reference.format_codeword"><code class="name flex">
<span>def <span class="ident">format_codeword</span></span>(<span>codeword: str)</span>
</code></dt>
<dd>
<div class="desc"><p>[summary]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>codeword</code></strong> :&ensp;<code>str</code></dt>
<dd>codeword representing a gene</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>byte</code></dt>
<dd>codeword converted in byte representation</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def format_codeword(codeword: str):
    &#34;&#34;&#34;[summary]

    Args:
        codeword (str): codeword representing a gene

    Returns:
        byte: codeword converted in byte representation
    &#34;&#34;&#34;
    str_num = codeword.split(&#39;[&#39;)[-1].split(&#39;]&#39;)[0]
    converted_codeword = np.array([int(el) for el in list(str_num)]).astype(np.int8)
    converted_codeword = converted_codeword.tobytes()
    return converted_codeword</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pysmFISH.barcodes_analysis.simplify_barcodes_reference.convert_codebook"><code class="name flex">
<span>def <span class="ident">convert_codebook</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_codebook(self):
    used_gene_codebook_df = pd.read_excel(self.barcode_fpath)
    # used_gene_codebook_df = pd.read_parquet(self.barcode_fpath)
    self.codebook_df = used_gene_codebook_df.loc[:,[&#39;Barcode&#39;,&#39;Gene&#39;]]
    self.codebook_df.rename(columns = {&#39;Barcode&#39;:&#39;Code&#39;}, inplace = True)
    self.codebook_df.Code = self.codebook_df.Code.apply(lambda x: self.format_codeword(x))
    self.codebook_df.to_parquet(self.barcode_fpath.parent / (self.barcode_fname + &#39;.parquet&#39;))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pysmFISH" href="index.html">pysmFISH</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pysmFISH.barcodes_analysis.chunk_dfs" href="#pysmFISH.barcodes_analysis.chunk_dfs">chunk_dfs</a></code></li>
<li><code><a title="pysmFISH.barcodes_analysis.convert_str_codebook" href="#pysmFISH.barcodes_analysis.convert_str_codebook">convert_str_codebook</a></code></li>
<li><code><a title="pysmFISH.barcodes_analysis.decoder_fun" href="#pysmFISH.barcodes_analysis.decoder_fun">decoder_fun</a></code></li>
<li><code><a title="pysmFISH.barcodes_analysis.define_flip_direction" href="#pysmFISH.barcodes_analysis.define_flip_direction">define_flip_direction</a></code></li>
<li><code><a title="pysmFISH.barcodes_analysis.dots_hoods" href="#pysmFISH.barcodes_analysis.dots_hoods">dots_hoods</a></code></li>
<li><code><a title="pysmFISH.barcodes_analysis.extract_barcodes_NN_fast" href="#pysmFISH.barcodes_analysis.extract_barcodes_NN_fast">extract_barcodes_NN_fast</a></code></li>
<li><code><a title="pysmFISH.barcodes_analysis.extract_barcodes_NN_fast_multicolor" href="#pysmFISH.barcodes_analysis.extract_barcodes_NN_fast_multicolor">extract_barcodes_NN_fast_multicolor</a></code></li>
<li><code><a title="pysmFISH.barcodes_analysis.extract_dots_images" href="#pysmFISH.barcodes_analysis.extract_dots_images">extract_dots_images</a></code></li>
<li><code><a title="pysmFISH.barcodes_analysis.identify_flipped_bits" href="#pysmFISH.barcodes_analysis.identify_flipped_bits">identify_flipped_bits</a></code></li>
<li><code><a title="pysmFISH.barcodes_analysis.make_codebook_array" href="#pysmFISH.barcodes_analysis.make_codebook_array">make_codebook_array</a></code></li>
<li><code><a title="pysmFISH.barcodes_analysis.merge_with_concat" href="#pysmFISH.barcodes_analysis.merge_with_concat">merge_with_concat</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pysmFISH.barcodes_analysis.extract_barcodes" href="#pysmFISH.barcodes_analysis.extract_barcodes">extract_barcodes</a></code></h4>
<ul class="">
<li><code><a title="pysmFISH.barcodes_analysis.extract_barcodes.barcode_detection" href="#pysmFISH.barcodes_analysis.extract_barcodes.barcode_detection">barcode_detection</a></code></li>
<li><code><a title="pysmFISH.barcodes_analysis.extract_barcodes.combine_coords" href="#pysmFISH.barcodes_analysis.extract_barcodes.combine_coords">combine_coords</a></code></li>
<li><code><a title="pysmFISH.barcodes_analysis.extract_barcodes.dots_hoods" href="#pysmFISH.barcodes_analysis.extract_barcodes.dots_hoods">dots_hoods</a></code></li>
<li><code><a title="pysmFISH.barcodes_analysis.extract_barcodes.run_extraction" href="#pysmFISH.barcodes_analysis.extract_barcodes.run_extraction">run_extraction</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pysmFISH.barcodes_analysis.extract_barcodes_NN" href="#pysmFISH.barcodes_analysis.extract_barcodes_NN">extract_barcodes_NN</a></code></h4>
<ul class="">
<li><code><a title="pysmFISH.barcodes_analysis.extract_barcodes_NN.barcode_nn" href="#pysmFISH.barcodes_analysis.extract_barcodes_NN.barcode_nn">barcode_nn</a></code></li>
<li><code><a title="pysmFISH.barcodes_analysis.extract_barcodes_NN.convert_str_codebook" href="#pysmFISH.barcodes_analysis.extract_barcodes_NN.convert_str_codebook">convert_str_codebook</a></code></li>
<li><code><a title="pysmFISH.barcodes_analysis.extract_barcodes_NN.make_codebook_array" href="#pysmFISH.barcodes_analysis.extract_barcodes_NN.make_codebook_array">make_codebook_array</a></code></li>
<li><code><a title="pysmFISH.barcodes_analysis.extract_barcodes_NN.run_extraction" href="#pysmFISH.barcodes_analysis.extract_barcodes_NN.run_extraction">run_extraction</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pysmFISH.barcodes_analysis.extract_barcodes_NN_new" href="#pysmFISH.barcodes_analysis.extract_barcodes_NN_new">extract_barcodes_NN_new</a></code></h4>
<ul class="">
<li><code><a title="pysmFISH.barcodes_analysis.extract_barcodes_NN_new.barcode_nn" href="#pysmFISH.barcodes_analysis.extract_barcodes_NN_new.barcode_nn">barcode_nn</a></code></li>
<li><code><a title="pysmFISH.barcodes_analysis.extract_barcodes_NN_new.convert_str_codebook" href="#pysmFISH.barcodes_analysis.extract_barcodes_NN_new.convert_str_codebook">convert_str_codebook</a></code></li>
<li><code><a title="pysmFISH.barcodes_analysis.extract_barcodes_NN_new.make_codebook_array" href="#pysmFISH.barcodes_analysis.extract_barcodes_NN_new.make_codebook_array">make_codebook_array</a></code></li>
<li><code><a title="pysmFISH.barcodes_analysis.extract_barcodes_NN_new.run_extraction" href="#pysmFISH.barcodes_analysis.extract_barcodes_NN_new.run_extraction">run_extraction</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pysmFISH.barcodes_analysis.extract_barcodes_NN_test" href="#pysmFISH.barcodes_analysis.extract_barcodes_NN_test">extract_barcodes_NN_test</a></code></h4>
<ul class="">
<li><code><a title="pysmFISH.barcodes_analysis.extract_barcodes_NN_test.barcode_nn" href="#pysmFISH.barcodes_analysis.extract_barcodes_NN_test.barcode_nn">barcode_nn</a></code></li>
<li><code><a title="pysmFISH.barcodes_analysis.extract_barcodes_NN_test.convert_str_codebook" href="#pysmFISH.barcodes_analysis.extract_barcodes_NN_test.convert_str_codebook">convert_str_codebook</a></code></li>
<li><code><a title="pysmFISH.barcodes_analysis.extract_barcodes_NN_test.make_codebook_array" href="#pysmFISH.barcodes_analysis.extract_barcodes_NN_test.make_codebook_array">make_codebook_array</a></code></li>
<li><code><a title="pysmFISH.barcodes_analysis.extract_barcodes_NN_test.run_extraction" href="#pysmFISH.barcodes_analysis.extract_barcodes_NN_test.run_extraction">run_extraction</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pysmFISH.barcodes_analysis.simplify_barcodes_reference" href="#pysmFISH.barcodes_analysis.simplify_barcodes_reference">simplify_barcodes_reference</a></code></h4>
<ul class="">
<li><code><a title="pysmFISH.barcodes_analysis.simplify_barcodes_reference.convert_codebook" href="#pysmFISH.barcodes_analysis.simplify_barcodes_reference.convert_codebook">convert_codebook</a></code></li>
<li><code><a title="pysmFISH.barcodes_analysis.simplify_barcodes_reference.format_codeword" href="#pysmFISH.barcodes_analysis.simplify_barcodes_reference.format_codeword">format_codeword</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>